<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Floating Market Adventure - Enhanced Edition</title>
    <!-- Favicon and Icons -->
    <link rel="icon" type="image/png" sizes="32x32" href="../images/1.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="../images/1.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="../images/1.png" />
    <link rel="shortcut icon" href="../images/1.png" />
    <link rel="icon" href="../images/1.png" />


    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: #1a4d5e;
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        touch-action: none;
      }

      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(to bottom, #5fb3d3 0%, #2e8ba6 100%);
        overflow: hidden;
      }

      #canvas {
        display: block;
        width: 100%;
        height: 100%;
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-crisp-edges;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
      }

      #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        font-size: 18px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        z-index: 10;
        pointer-events: none;
      }

      #score,
      #timer,
      #collected,
      #combo,
      #highScore,
      #level {
        background: linear-gradient(
          135deg,
          rgba(0, 0, 0, 0.7),
          rgba(40, 40, 40, 0.6)
        );
        padding: 10px 16px;
        border-radius: 12px;
        margin-bottom: 10px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(5px);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        font-weight: bold;
        letter-spacing: 0.5px;
      }

      #highScore {
        background: linear-gradient(
          135deg,
          rgba(255, 215, 0, 0.2),
          rgba(218, 165, 32, 0.2)
        );
        border-color: rgba(255, 215, 0, 0.5);
      }

      #level {
        background: linear-gradient(
          135deg,
          rgba(76, 175, 80, 0.3),
          rgba(56, 142, 60, 0.3)
        );
        border-color: rgba(76, 175, 80, 0.5);
      }

      #minimap {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 200px;
        height: 160px;
        background: rgba(0, 0, 0, 0.8);
        border: 3px solid #8b4513;
        border-radius: 8px;
        z-index: 10;
        pointer-events: none;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      }

      #combo {
        background: rgba(255, 215, 0, 0.3);
        border: 2px solid #ffd700;
        font-weight: bold;
        animation: pulse 0.5s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      @keyframes fadeOut {
        from {
          opacity: 1;
          transform: translateY(0);
        }
        to {
          opacity: 0;
          transform: translateY(-30px);
        }
      }

      .float-text {
        position: absolute;
        color: #ffd700;
        font-weight: bold;
        font-size: 24px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        animation: fadeOut 1s forwards;
        pointer-events: none;
        z-index: 15;
      }

      #gameOver {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.95);
        color: white;
        padding: 40px;
        border-radius: 15px;
        text-align: center;
        display: none;
        z-index: 20;
        max-height: 90vh;
        overflow-y: auto;
      }

      #gameOver h2 {
        font-size: 36px;
        margin-bottom: 20px;
        color: #ffd700;
      }

      #gameOver button {
        background: #4caf50;
        color: white;
        border: none;
        padding: 15px 30px;
        font-size: 18px;
        border-radius: 8px;
        cursor: pointer;
        margin-top: 20px;
        transition: all 0.3s;
      }

      #gameOver button:hover {
        background: #45a049;
        transform: scale(1.05);
      }

      .food-name {
        font-size: 16px;
        margin: 5px 0;
      }

      #startScreen,
      #pauseScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        z-index: 25;
      }

      #pauseScreen {
        display: none;
      }

      #startScreen h1,
      #pauseScreen h1 {
        font-size: 48px;
        margin-bottom: 30px;
        color: #ffd700;
      }

      .controls {
        background: rgba(255, 255, 255, 0.1);
        padding: 20px;
        border-radius: 10px;
        margin: 20px 0;
        max-width: 400px;
      }

      .controls h3 {
        margin-bottom: 15px;
        color: #ffd700;
      }

      .controls p {
        margin: 10px 0;
        line-height: 1.6;
      }

      .start-btn,
      .resume-btn {
        background: #4caf50;
        color: white;
        border: none;
        padding: 20px 40px;
        font-size: 24px;
        border-radius: 10px;
        cursor: pointer;
        margin-top: 20px;
        transition: all 0.3s;
      }

      .start-btn:hover,
      .resume-btn:hover {
        background: #45a049;
        transform: scale(1.1);
      }

      .achievements {
        margin-top: 20px;
        padding: 15px;
        background: rgba(255, 215, 0, 0.1);
        border-radius: 10px;
        border: 2px solid #ffd700;
      }

      .achievement {
        display: inline-block;
        margin: 5px;
        padding: 5px 10px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 5px;
        font-size: 14px;
      }

      .achievement.unlocked {
        background: rgba(76, 175, 80, 0.3);
        border: 1px solid #4caf50;
      }

      .power-up-indicator {
        position: absolute;
        top: 20px;
        right: 20px;
        font-size: 48px;
        z-index: 10;
        pointer-events: none;
        text-shadow: 0 0 20px currentColor;
        animation: powerUpFloat 1s ease-in-out infinite;
      }

      @keyframes powerUpFloat {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-10px);
        }
      }

      #timeBar {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 300px;
        height: 20px;
        background: rgba(0, 0, 0, 0.7);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 10px;
        overflow: hidden;
        z-index: 10;
      }

      #timeBarFill {
        height: 100%;
        background: linear-gradient(90deg, #4caf50, #8bc34a);
        transition: width 0.3s ease, background 0.3s ease;
      }

      #timeBarFill.warning {
        background: linear-gradient(90deg, #ff9800, #ffc107);
      }

      #timeBarFill.danger {
        background: linear-gradient(90deg, #f44336, #ff5722);
        animation: pulse 0.5s infinite;
      }

      @media (max-width: 850px) {
        #gameContainer {
          width: 95vw;
          height: 70vh;
        }

        #startScreen h1,
        #pauseScreen h1 {
          font-size: 32px;
        }

        .start-btn,
        .resume-btn {
          padding: 15px 30px;
          font-size: 20px;
        }
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="canvas"></canvas>
      <div id="ui">
        <div id="highScore">High Score: 0</div>
        <div id="level">Level: 1</div>
        <div id="score">Score: 0</div>
        <div id="timer">Time: 90s</div>
        <div id="collected">Collected: 0/15</div>
        <div id="combo" style="display: none">Combo: 0x</div>
      </div>
      <div id="powerUpIndicator" class="power-up-indicator"></div>
      <div id="timeBar">
        <div id="timeBarFill"></div>
      </div>
      <canvas id="minimap"></canvas>

      <div id="startScreen">
        <h1>üõ∂ Floating Market Maze üõ∂</h1>
        <div class="controls">
          <h3>How to Play:</h3>
          <p>üó∫Ô∏è Navigate through the floating market maze</p>
          <p>ÔøΩ Collect stationary food items scattered around</p>
          <p>üöß Avoid walls and obstacles!</p>
          <p>
            ‚≠ê Power-ups: ‚è∞ Time +15s | üöÄ Speed Boost | ‚ú® 2x Multiplier | üëª
            Ghost Mode
          </p>
          <p>üî• Build combos for bonus points!</p>
          <p>üìç Use the minimap to navigate</p>
          <p>üèÅ Complete levels to unlock harder mazes!</p>
          <p><strong>Desktop:</strong> Arrow keys to move | P to pause</p>
          <p><strong>Mobile:</strong> Touch/drag to move boat</p>
        </div>
        <button class="start-btn" onclick="startGame()">Start Game</button>
      </div>

      <div id="pauseScreen">
        <h1>‚è∏Ô∏è Paused</h1>
        <button class="resume-btn" onclick="togglePause()">Resume</button>
        <button
          class="resume-btn"
          onclick="quitToMenu()"
          style="background: #f44336; margin-top: 10px"
        >
          Main Menu
        </button>
      </div>

      <div id="gameOver">
        <h2>Game Over!</h2>
        <p id="finalScore"></p>
        <p id="highScoreMessage"></p>
        <div id="foodList"></div>
        <div id="achievements" class="achievements"></div>
        <button onclick="restartGame()">Play Again</button>
        <button
          onclick="quitToMenu()"
          style="background: #2196f3; margin-left: 10px"
        >
          Main Menu
        </button>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      // Make canvas fullscreen
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      // World size - much larger than viewport
      const WORLD_WIDTH = 3000;
      const WORLD_HEIGHT = 2400;

      const foodItems = [
        { name: "Mango", emoji: "ü•≠", color: "#FFB347", points: 10 },
        { name: "Banana", emoji: "üçå", color: "#FFE135", points: 10 },
        { name: "Papaya", emoji: "üçà", color: "#FF8C42", points: 10 },
        { name: "Coconut", emoji: "ü••", color: "#8B4513", points: 15 },
        { name: "Pineapple", emoji: "üçç", color: "#FFD700", points: 15 },
        { name: "Watermelon", emoji: "üçâ", color: "#FF6B6B", points: 12 },
        { name: "Rice", emoji: "üçö", color: "#F5F5DC", points: 8 },
        { name: "Noodles", emoji: "üçú", color: "#FFA07A", points: 12 },
        { name: "Fish", emoji: "üêü", color: "#4682B4", points: 20 },
        { name: "Shrimp", emoji: "ü¶ê", color: "#FF69B4", points: 18 },
        { name: "Dragon Fruit", emoji: "üêâ", color: "#FF1493", points: 25 },
        { name: "Lychee", emoji: "üçá", color: "#DDA0DD", points: 14 },
        { name: "Durian", emoji: "üå∞", color: "#8B7355", points: 22 },
        { name: "Rambutan", emoji: "üî¥", color: "#DC143C", points: 16 },
        { name: "Crab", emoji: "ü¶Ä", color: "#FF6347", points: 28 },
        { name: "Lobster", emoji: "ü¶û", color: "#B22222", points: 30 },
        { name: "Squid", emoji: "ü¶ë", color: "#9370DB", points: 24 },
        { name: "Soup", emoji: "üç≤", color: "#FF8C00", points: 18 },
        { name: "Curry", emoji: "üçõ", color: "#DAA520", points: 20 },
        { name: "Dumplings", emoji: "ü•ü", color: "#F0E68C", points: 16 },
      ];

      const powerUps = [
        {
          name: "Time",
          emoji: "‚è∞",
          effect: "time",
          duration: 0,
          color: "#00FFFF",
        },
        {
          name: "Speed",
          emoji: "üöÄ",
          effect: "speed",
          duration: 6000,
          color: "#00FF00",
        },
        {
          name: "Multiplier",
          emoji: "‚ú®",
          effect: "multiplier",
          duration: 8000,
          color: "#FFD700",
        },
        {
          name: "Ghost",
          emoji: "üëª",
          effect: "ghost",
          duration: 5000,
          color: "#9370DB",
        },
      ];

      let boat = {
        x: 150,
        y: 150,
        width: 60,
        height: 45,
        speed: 4,
        baseSpeed: 4,
        radius: 30,
      };

      // Camera system
      let camera = {
        x: 0,
        y: 0,
        smoothing: 0.1,
      };

      let foods = [];
      let walls = [];
      let obstacles = [];
      let particles = [];
      let score = 0;
      let timeLeft = 90;
      let gameActive = false;
      let gamePaused = false;
      let gameStarted = false;
      let collectedFoods = {};
      let keys = {};
      let combo = 0;
      let comboTimer = null;
      let highScore = localStorage.getItem("floatingMarketHighScore") || 0;
      let activePowerUp = null;
      let powerUpEndTime = 0;
      let scoreMultiplier = 1;
      let currentLevel = 1;
      let totalCollected = 0;
      let perfectCatches = 0;
      let speedBoostCount = 0;
      let ghostMode = false;
      let collisionsAvoided = 0;
      let foodsInLevel = 15;

      // Touch controls
      let touchStartX = 0;
      let touchStartY = 0;
      let isTouching = false;

      // Minimap
      const minimapCanvas = document.getElementById("minimap");
      const minimapCtx = minimapCanvas.getContext("2d");
      minimapCanvas.width = 200;
      minimapCanvas.height = 160;

      // Market decorations and stalls
      let marketStalls = [];
      let floatingVendors = [];
      let waterLilies = [];
      let lanterns = [];
      let specialItems = [];
      let boatTrail = [];
      let marketSigns = [];
      let dangerousObstacles = [];

      // Visual enhancements
      let timeOfDay = 0; // 0-1 for day/night cycle
      let weatherEffect = "clear"; // clear, rain, fog
      let raindrops = [];
      let weatherChangeTimer = 0;

      function generateMaze() {
        walls = [];
        obstacles = [];
        marketStalls = [];
        floatingVendors = [];
        waterLilies = [];

        // Border walls - using world size
        const borderThickness = 30;
        walls.push({
          x: 0,
          y: 0,
          width: WORLD_WIDTH,
          height: borderThickness,
          type: "border",
        }); // Top
        walls.push({
          x: 0,
          y: WORLD_HEIGHT - borderThickness,
          width: WORLD_WIDTH,
          height: borderThickness,
          type: "border",
        }); // Bottom
        walls.push({
          x: 0,
          y: 0,
          width: borderThickness,
          height: WORLD_HEIGHT,
          type: "border",
        }); // Left
        walls.push({
          x: WORLD_WIDTH - borderThickness,
          y: 0,
          width: borderThickness,
          height: WORLD_HEIGHT,
          type: "border",
        }); // Right

        // Create market stalls (act as walls but look like stalls)
        const stallsPerRow = 8 + currentLevel;
        const stallSpacingX = WORLD_WIDTH / (stallsPerRow + 1);
        const stallsPerCol = 6 + currentLevel;
        const stallSpacingY = WORLD_HEIGHT / (stallsPerCol + 1);

        for (let row = 0; row < stallsPerCol; row++) {
          for (let col = 0; col < stallsPerRow; col++) {
            if (Math.random() < 0.6) {
              // 60% chance for a stall
              const x = (col + 1) * stallSpacingX + (Math.random() - 0.5) * 100;
              const y = (row + 1) * stallSpacingY + (Math.random() - 0.5) * 100;

              // Ensure not near starting position
              const distToStart = Math.sqrt(
                (x - boat.x) ** 2 + (y - boat.y) ** 2
              );
              if (distToStart > 200) {
                const stallWidth = 80 + Math.random() * 60;
                const stallHeight = 80 + Math.random() * 60;

                walls.push({
                  x,
                  y,
                  width: stallWidth,
                  height: stallHeight,
                  type: "stall",
                  color: ["#D2691E", "#CD853F", "#DEB887", "#F4A460"][
                    Math.floor(Math.random() * 4)
                  ],
                  roofColor: ["#8B4513", "#A0522D", "#8B6914"][
                    Math.floor(Math.random() * 3)
                  ],
                  hasAwning: Math.random() > 0.5,
                });
              }
            }
          }
        }

        // Add connecting pathways with decorative barriers
        const numPathways = 10 + currentLevel * 3;
        for (let i = 0; i < numPathways; i++) {
          const isHorizontal = Math.random() > 0.5;

          if (isHorizontal) {
            const y = 200 + Math.random() * (WORLD_HEIGHT - 400);
            const x = 200 + Math.random() * (WORLD_WIDTH - 600);
            const width = 150 + Math.random() * 200;
            walls.push({
              x,
              y,
              width,
              height: 25,
              type: "fence",
              color: "#8B7355",
            });
          } else {
            const x = 200 + Math.random() * (WORLD_WIDTH - 400);
            const y = 200 + Math.random() * (WORLD_HEIGHT - 600);
            const height = 150 + Math.random() * 200;
            walls.push({
              x,
              y,
              width: 25,
              height,
              type: "fence",
              color: "#8B7355",
            });
          }
        }

        // Add floating vendors as moving obstacles
        const numVendors = 3 + Math.floor(currentLevel / 2);
        for (let i = 0; i < numVendors; i++) {
          floatingVendors.push({
            x: 300 + Math.random() * (WORLD_WIDTH - 600),
            y: 300 + Math.random() * (WORLD_HEIGHT - 600),
            radius: 35,
            vx: (Math.random() - 0.5) * 1.5,
            vy: (Math.random() - 0.5) * 1.5,
            emoji: ["üö§", "‚õµ", "üõ∂"][Math.floor(Math.random() * 3)],
            color: "#FF6B6B",
          });
        }

        // Add decorative water lilies (non-collision)
        for (let i = 0; i < 60; i++) {
          waterLilies.push({
            x: Math.random() * WORLD_WIDTH,
            y: Math.random() * WORLD_HEIGHT,
            size: 20 + Math.random() * 20,
            rotation: Math.random() * Math.PI * 2,
            type: ["üå∏", "üå∫", "ü™∑"][Math.floor(Math.random() * 3)],
          });
        }

        // Add floating lanterns for atmosphere
        lanterns = [];
        for (let i = 0; i < 25; i++) {
          lanterns.push({
            x: Math.random() * WORLD_WIDTH,
            y: Math.random() * WORLD_HEIGHT,
            size: 25,
            glow: Math.random() * Math.PI * 2,
            color: ["#FFD700", "#FFA500", "#FF6B6B", "#FF69B4"][
              Math.floor(Math.random() * 4)
            ],
          });
        }

        // Add special bonus items (treasure chests, rare foods)
        specialItems = [];
        if (currentLevel >= 2) {
          const numSpecial = Math.floor(currentLevel / 2);
          for (let i = 0; i < numSpecial; i++) {
            let sx, sy;
            let validPos = false;
            let attempts = 0;

            while (!validPos && attempts < 50) {
              sx = 200 + Math.random() * (WORLD_WIDTH - 400);
              sy = 200 + Math.random() * (WORLD_HEIGHT - 400);
              validPos = true;

              for (let wall of walls) {
                if (
                  sx > wall.x - 50 &&
                  sx < wall.x + wall.width + 50 &&
                  sy > wall.y - 50 &&
                  sy < wall.y + wall.height + 50
                ) {
                  validPos = false;
                  break;
                }
              }
              attempts++;
            }

            if (validPos) {
              specialItems.push({
                x: sx,
                y: sy,
                type: ["üíé", "üèÜ", "‚≠ê", "üéÅ", "üëë", "üîÆ"][
                  Math.floor(Math.random() * 6)
                ],
                points: 50 + currentLevel * 25,
                collected: false,
                pulseOffset: Math.random() * Math.PI * 2,
              });
            }
          }
        }

        // Add colorful market signs
        marketSigns = [];
        const signTexts = [
          "üçú NOODLES",
          "üêü FISH",
          "üçå FRUITS",
          "ü•• COCONUT",
          "üçç FRESH",
          "ü¶ê SEAFOOD",
          "üçö RICE",
          "ü•≠ MANGO",
        ];
        const signColors = [
          "#FF6B6B",
          "#4ECDC4",
          "#45B7D1",
          "#FFA07A",
          "#98D8C8",
          "#F7DC6F",
          "#BB8FCE",
          "#85C1E2",
        ];

        for (let i = 0; i < 15 + currentLevel * 2; i++) {
          let sx, sy;
          let validPos = false;
          let attempts = 0;

          while (!validPos && attempts < 30) {
            sx = 200 + Math.random() * (WORLD_WIDTH - 400);
            sy = 200 + Math.random() * (WORLD_HEIGHT - 400);
            validPos = true;

            for (let wall of walls) {
              const dist = Math.sqrt(
                (sx - wall.x - wall.width / 2) ** 2 +
                  (sy - wall.y - wall.height / 2) ** 2
              );
              if (dist < 150) {
                validPos = false;
                break;
              }
            }
            attempts++;
          }

          if (validPos) {
            marketSigns.push({
              x: sx,
              y: sy,
              text: signTexts[Math.floor(Math.random() * signTexts.length)],
              color: signColors[Math.floor(Math.random() * signColors.length)],
              rotation: (Math.random() - 0.5) * 0.3,
              sway: Math.random() * Math.PI * 2,
            });
          }
        }

        // Add dangerous obstacles
        dangerousObstacles = [];
        const numDangers = 5 + currentLevel * 2;
        for (let i = 0; i < numDangers; i++) {
          let dx, dy;
          let validPos = false;
          let attempts = 0;

          while (!validPos && attempts < 50) {
            dx = 250 + Math.random() * (WORLD_WIDTH - 500);
            dy = 250 + Math.random() * (WORLD_HEIGHT - 500);
            const distToStart = Math.sqrt(
              (dx - boat.x) ** 2 + (dy - boat.y) ** 2
            );
            validPos = distToStart > 300;

            if (validPos) {
              for (let wall of walls) {
                const dist = Math.sqrt(
                  (dx - wall.x - wall.width / 2) ** 2 +
                    (dy - wall.y - wall.height / 2) ** 2
                );
                if (dist < 100) {
                  validPos = false;
                  break;
                }
              }
            }
            attempts++;
          }

          if (validPos) {
            const dangerType = Math.random();
            if (dangerType < 0.4) {
              // Whirlpools
              dangerousObstacles.push({
                x: dx,
                y: dy,
                radius: 40,
                type: "whirlpool",
                rotation: 0,
                active: true,
              });
            } else if (dangerType < 0.7) {
              // Floating debris
              dangerousObstacles.push({
                x: dx,
                y: dy,
                radius: 35,
                type: "debris",
                rotation: Math.random() * Math.PI * 2,
                vx: (Math.random() - 0.5) * 0.8,
                vy: (Math.random() - 0.5) * 0.8,
              });
            } else {
              // Fire obstacles
              dangerousObstacles.push({
                x: dx,
                y: dy,
                radius: 30,
                type: "fire",
                intensity: 0,
              });
            }
          }
        }
      }

      function createFood() {
        const isPowerUp = Math.random() < 0.15;
        let x, y;
        let attempts = 0;
        let validPosition = false;

        // Find a valid position not inside walls - use world coordinates
        while (!validPosition && attempts < 100) {
          x = 100 + Math.random() * (WORLD_WIDTH - 200);
          y = 100 + Math.random() * (WORLD_HEIGHT - 200);
          validPosition = true;

          // Check if position overlaps with walls
          for (let wall of walls) {
            if (
              x > wall.x - 40 &&
              x < wall.x + wall.width + 40 &&
              y > wall.y - 40 &&
              y < wall.y + wall.height + 40
            ) {
              validPosition = false;
              break;
            }
          }

          // Check if too close to boat starting position
          const distToBoat = Math.sqrt((x - boat.x) ** 2 + (y - boat.y) ** 2);
          if (distToBoat < 150) validPosition = false;

          attempts++;
        }

        if (isPowerUp) {
          const powerUpType =
            powerUps[Math.floor(Math.random() * powerUps.length)];
          return {
            x,
            y,
            width: 35,
            height: 35,
            type: powerUpType,
            collected: false,
            isPowerUp: true,
            rotation: 0,
            floatOffset: Math.random() * Math.PI * 2,
          };
        } else {
          const foodType =
            foodItems[Math.floor(Math.random() * foodItems.length)];
          return {
            x,
            y,
            width: 35,
            height: 35,
            type: foodType,
            collected: false,
            isPowerUp: false,
            wobble: Math.random() * Math.PI * 2,
            floatOffset: Math.random() * Math.PI * 2,
          };
        }
      }

      // Helper functions for color manipulation
      function lightenColor(color, percent) {
        const num = parseInt(color.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.min(255, (num >> 16) + amt);
        const G = Math.min(255, ((num >> 8) & 0x00ff) + amt);
        const B = Math.min(255, (num & 0x0000ff) + amt);
        return (
          "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1)
        );
      }

      function darkenColor(color, percent) {
        const num = parseInt(color.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.max(0, (num >> 16) - amt);
        const G = Math.max(0, ((num >> 8) & 0x00ff) - amt);
        const B = Math.max(0, (num & 0x0000ff) - amt);
        return (
          "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1)
        );
      }

      function initGame() {
        generateMaze();
        foods = [];
        for (let i = 0; i < foodsInLevel; i++) {
          foods.push(createFood());
        }
      }

      initGame();

      function updateCamera() {
        // Smooth camera follow
        const targetX = boat.x - canvas.width / 2;
        const targetY = boat.y - canvas.height / 2;

        camera.x += (targetX - camera.x) * camera.smoothing;
        camera.y += (targetY - camera.y) * camera.smoothing;

        // Keep camera within world bounds
        camera.x = Math.max(0, Math.min(WORLD_WIDTH - canvas.width, camera.x));
        camera.y = Math.max(
          0,
          Math.min(WORLD_HEIGHT - canvas.height, camera.y)
        );
      }

      function drawBoat() {
        ctx.save();

        const screenX = boat.x - camera.x;
        const screenY = boat.y - camera.y;

        // Draw shadow under boat
        if (!ghostMode) {
          ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
          ctx.beginPath();
          ctx.ellipse(
            screenX,
            screenY + 38,
            boat.width / 2 + 8,
            10,
            0,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }

        // Ghost mode transparency
        if (ghostMode) {
          ctx.globalAlpha = 0.5;
        }

        // Add glow effect if power-up is active
        if (activePowerUp) {
          ctx.shadowBlur = 30;
          ctx.shadowColor =
            activePowerUp === "speed"
              ? "#00FF00"
              : activePowerUp === "multiplier"
              ? "#FFD700"
              : activePowerUp === "ghost"
              ? "#9370DB"
              : "#FFFFFF";
        }

        // Draw boat hull - enhanced 3D wooden boat
        // Outer hull with gradient
        const hullGradient = ctx.createLinearGradient(
          screenX - boat.width / 2,
          screenY,
          screenX + boat.width / 2,
          screenY
        );
        hullGradient.addColorStop(0, "#654321");
        hullGradient.addColorStop(0.5, "#8B4513");
        hullGradient.addColorStop(1, "#654321");

        ctx.fillStyle = hullGradient;
        ctx.beginPath();
        ctx.moveTo(screenX, screenY - 12);
        ctx.lineTo(screenX - boat.width / 2 + 2, screenY + boat.height / 2 - 2);
        ctx.quadraticCurveTo(
          screenX,
          screenY + boat.height / 2 + 12,
          screenX + boat.width / 2 - 2,
          screenY + boat.height / 2 - 2
        );
        ctx.closePath();
        ctx.fill();

        // Hull outline
        ctx.strokeStyle = "#3D2817";
        ctx.lineWidth = 3;
        ctx.stroke();

        // Hull highlight
        ctx.strokeStyle = "rgba(139, 90, 43, 0.6)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(screenX - boat.width / 2 + 8, screenY + boat.height / 2 - 5);
        ctx.quadraticCurveTo(
          screenX,
          screenY + boat.height / 2 + 8,
          screenX + boat.width / 2 - 8,
          screenY + boat.height / 2 - 5
        );
        ctx.stroke();

        // Boat interior with gradient
        const interiorGradient = ctx.createLinearGradient(
          screenX - 22,
          screenY + 5,
          screenX + 22,
          screenY + 25
        );
        interiorGradient.addColorStop(0, "#A0522D");
        interiorGradient.addColorStop(0.5, "#D2691E");
        interiorGradient.addColorStop(1, "#8B4513");
        ctx.fillStyle = interiorGradient;
        ctx.fillRect(screenX - 22, screenY + 5, 44, 20);

        // Interior rim
        ctx.strokeStyle = "#654321";
        ctx.lineWidth = 2;
        ctx.strokeRect(screenX - 22, screenY + 5, 44, 20);

        // Wood planks detail with depth
        ctx.strokeStyle = "#8B6914";
        ctx.lineWidth = 2;
        for (let i = -18; i < 24; i += 9) {
          ctx.beginPath();
          ctx.moveTo(screenX + i, screenY + 6);
          ctx.lineTo(screenX + i, screenY + 24);
          ctx.stroke();
        }

        // Decorative rope around boat
        ctx.strokeStyle = "#DEB887";
        ctx.lineWidth = 2;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(screenX - boat.width / 2 + 5, screenY + boat.height / 2 - 8);
        ctx.lineTo(screenX + boat.width / 2 - 5, screenY + boat.height / 2 - 8);
        ctx.stroke();
        ctx.setLineDash([]);

        // Enhanced mast with wood texture
        const mastGradient = ctx.createLinearGradient(
          screenX - 3,
          screenY - 45,
          screenX + 3,
          screenY - 45
        );
        mastGradient.addColorStop(0, "#3D2817");
        mastGradient.addColorStop(0.5, "#654321");
        mastGradient.addColorStop(1, "#3D2817");

        ctx.fillStyle = mastGradient;
        ctx.fillRect(screenX - 3, screenY - 45, 6, 50);
        ctx.strokeStyle = "#2D1810";
        ctx.lineWidth = 1;
        ctx.strokeRect(screenX - 3, screenY - 45, 6, 50);

        // Sail with better shape and gradient
        const sailGradient = ctx.createLinearGradient(
          screenX,
          screenY - 45,
          screenX + 30,
          screenY - 10
        );
        if (ghostMode) {
          sailGradient.addColorStop(0, "rgba(147, 112, 219, 0.8)");
          sailGradient.addColorStop(1, "rgba(186, 165, 219, 0.6)");
        } else {
          sailGradient.addColorStop(0, "#FFF8DC");
          sailGradient.addColorStop(0.5, "#FFE4B5");
          sailGradient.addColorStop(1, "#F5DEB3");
        }

        ctx.fillStyle = sailGradient;
        ctx.strokeStyle = "#DEB887";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(screenX, screenY - 43);
        ctx.quadraticCurveTo(screenX + 32, screenY - 25, screenX + 5, screenY);
        ctx.lineTo(screenX, screenY - 5);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Sail horizontal lines
        ctx.strokeStyle = "#CD853F";
        ctx.lineWidth = 1;
        for (let i = 0; i < 4; i++) {
          const y = screenY - 38 + i * 10;
          ctx.beginPath();
          ctx.moveTo(screenX + 2, y);
          ctx.lineTo(screenX + 28 - i * 6, y);
          ctx.stroke();
        }

        // Flag at top of mast
        ctx.fillStyle = activePowerUp ? "#FFD700" : "#FF6B6B";
        ctx.beginPath();
        ctx.moveTo(screenX, screenY - 45);
        ctx.lineTo(screenX + 15, screenY - 40);
        ctx.lineTo(screenX, screenY - 35);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "#B22222";
        ctx.lineWidth = 1;
        ctx.stroke();

        // Lantern on boat
        ctx.fillStyle = "#FFD700";
        ctx.beginPath();
        ctx.arc(screenX - 18, screenY + 8, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#B8860B";
        ctx.lineWidth = 1;
        ctx.stroke();

        // Lantern glow
        ctx.shadowBlur = 10;
        ctx.shadowColor = "#FFD700";
        ctx.fillStyle = "rgba(255, 215, 0, 0.3)";
        ctx.beginPath();
        ctx.arc(screenX - 18, screenY + 8, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#CD853F";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(screenX, screenY - 30);
        ctx.lineTo(screenX + 20, screenY - 18);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(screenX, screenY - 20);
        ctx.lineTo(screenX + 23, screenY - 15);
        ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
        ctx.restore();
      }

      function drawFood(food) {
        ctx.save();

        const screenX = food.x - camera.x;
        const screenY = food.y - camera.y;

        // Floating animation
        food.floatOffset += 0.03;
        const floatY = Math.sin(food.floatOffset) * 5;

        if (food.isPowerUp) {
          // Rotate power-ups
          food.rotation += 0.05;
          ctx.translate(screenX, screenY + floatY);
          ctx.rotate(food.rotation);

          // Add glow to power-ups
          ctx.shadowBlur = 20;
          ctx.shadowColor = food.type.color;
          ctx.font = "bold 40px Arial";
          ctx.fillText(food.type.emoji, -20, 20);
        } else {
          // Wobble effect for food
          food.wobble += 0.05;
          const wobbleX = Math.sin(food.wobble) * 2;
          ctx.font = "36px Arial";
          ctx.fillText(
            food.type.emoji,
            screenX - 18 + wobbleX,
            screenY + 22 + floatY
          );
        }

        ctx.restore();
      }

      function drawWaterLilies() {
        for (let lily of waterLilies) {
          const screenX = lily.x - camera.x;
          const screenY = lily.y - camera.y;

          // Only draw if on screen
          if (
            screenX > -50 &&
            screenX < canvas.width + 50 &&
            screenY > -50 &&
            screenY < canvas.height + 50
          ) {
            ctx.save();
            ctx.globalAlpha = 0.7;
            ctx.font = lily.size + "px Arial";
            ctx.fillText(
              lily.type,
              screenX - lily.size / 2,
              screenY + lily.size / 2
            );
            ctx.restore();
          }
        }
      }

      function drawWalls() {
        for (let wall of walls) {
          const screenX = wall.x - camera.x;
          const screenY = wall.y - camera.y;

          // Only draw if on screen (with margin)
          if (
            screenX + wall.width < -100 ||
            screenX > canvas.width + 100 ||
            screenY + wall.height < -100 ||
            screenY > canvas.height + 100
          ) {
            continue;
          }

          ctx.save();

          if (wall.type === "stall") {
            // Draw enhanced market stall with 3D effect
            // Roof/Awning with gradient
            if (wall.hasAwning) {
              const roofGradient = ctx.createLinearGradient(
                screenX,
                screenY - 20,
                screenX,
                screenY
              );
              roofGradient.addColorStop(0, wall.roofColor);
              roofGradient.addColorStop(1, "#654321");

              ctx.fillStyle = roofGradient;
              ctx.beginPath();
              ctx.moveTo(screenX - 12, screenY - 20);
              ctx.lineTo(screenX + wall.width + 12, screenY - 20);
              ctx.lineTo(screenX + wall.width + 8, screenY);
              ctx.lineTo(screenX - 8, screenY);
              ctx.closePath();
              ctx.fill();

              // Awning shadow
              ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
              ctx.fillRect(screenX - 6, screenY, wall.width + 12, 5);

              // Colorful awning stripes
              const stripeColors = ["#FF6B6B", "#4ECDC4", "#FFD93D", "#6BCF7F"];
              for (let i = 0; i < wall.width; i += 25) {
                ctx.fillStyle =
                  stripeColors[Math.floor((i / 25) % stripeColors.length)];
                ctx.fillRect(screenX + i - 8, screenY - 20, 25, 20);
              }

              // Awning outline
              ctx.strokeStyle = "#3D2817";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(screenX - 12, screenY - 20);
              ctx.lineTo(screenX + wall.width + 12, screenY - 20);
              ctx.lineTo(screenX + wall.width + 8, screenY);
              ctx.lineTo(screenX - 8, screenY);
              ctx.closePath();
              ctx.stroke();
            }

            // Stall body with gradient and depth
            const bodyGradient = ctx.createLinearGradient(
              screenX,
              screenY,
              screenX + wall.width,
              screenY + wall.height
            );
            const baseColor = wall.color;
            bodyGradient.addColorStop(0, baseColor);
            bodyGradient.addColorStop(0.5, lightenColor(baseColor, 20));
            bodyGradient.addColorStop(1, darkenColor(baseColor, 20));

            ctx.fillStyle = bodyGradient;
            ctx.fillRect(screenX, screenY, wall.width, wall.height);

            // Stall outline
            ctx.strokeStyle = "#3D2817";
            ctx.lineWidth = 4;
            ctx.strokeRect(screenX, screenY, wall.width, wall.height);

            // Wooden planks with varied thickness
            ctx.strokeStyle = "#8B6914";
            for (let i = 0; i < wall.height; i += 18) {
              ctx.lineWidth = 2 + Math.sin(i) * 0.5;
              ctx.beginPath();
              ctx.moveTo(screenX, screenY + i);
              ctx.lineTo(screenX + wall.width, screenY + i);
              ctx.stroke();
            }

            // Vertical support beams
            ctx.strokeStyle = "#654321";
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(screenX + 10, screenY);
            ctx.lineTo(screenX + 10, screenY + wall.height);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(screenX + wall.width - 10, screenY);
            ctx.lineTo(screenX + wall.width - 10, screenY + wall.height);
            ctx.stroke();

            // Counter/display area with items
            const counterGradient = ctx.createLinearGradient(
              screenX + 5,
              screenY + wall.height - 30,
              screenX + 5,
              screenY + wall.height - 5
            );
            counterGradient.addColorStop(0, "#8B4513");
            counterGradient.addColorStop(1, "#A0522D");
            ctx.fillStyle = counterGradient;
            ctx.fillRect(
              screenX + 5,
              screenY + wall.height - 30,
              wall.width - 10,
              25
            );

            ctx.strokeStyle = "#654321";
            ctx.lineWidth = 2;
            ctx.strokeRect(
              screenX + 5,
              screenY + wall.height - 30,
              wall.width - 10,
              25
            );

            // Display items on counter (baskets, crates)
            const items = ["üß∫", "üì¶", "ü•°", "üç±"];
            const numItems = Math.min(3, Math.floor(wall.width / 35));
            for (let i = 0; i < numItems; i++) {
              const itemX = screenX + 15 + (i * (wall.width - 30)) / numItems;
              const itemY = screenY + wall.height - 25;
              ctx.font = "20px Arial";
              ctx.fillText(items[i % items.length], itemX, itemY);
            }

            // Hanging decorations
            if (wall.hasAwning && Math.random() > 0.5) {
              ctx.fillStyle = "#FFD700";
              for (let i = 0; i < 3; i++) {
                const decX = screenX + 20 + (i * (wall.width - 40)) / 2;
                ctx.beginPath();
                ctx.arc(decX, screenY - 8, 3, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          } else if (wall.type === "fence") {
            // Draw bamboo fence
            ctx.fillStyle = wall.color;
            ctx.fillRect(screenX, screenY, wall.width, wall.height);
            ctx.strokeStyle = "#654321";
            ctx.lineWidth = 2;
            ctx.strokeRect(screenX, screenY, wall.width, wall.height);

            // Bamboo segments
            const segmentSize = 15;
            ctx.strokeStyle = "#6B5D4F";
            ctx.lineWidth = 1;
            if (wall.width > wall.height) {
              for (let i = 0; i < wall.width; i += segmentSize) {
                ctx.beginPath();
                ctx.moveTo(screenX + i, screenY);
                ctx.lineTo(screenX + i, screenY + wall.height);
                ctx.stroke();
              }
            } else {
              for (let i = 0; i < wall.height; i += segmentSize) {
                ctx.beginPath();
                ctx.moveTo(screenX, screenY + i);
                ctx.lineTo(screenX + wall.width, screenY + i);
                ctx.stroke();
              }
            }
          } else {
            // Border walls
            ctx.fillStyle = "#654321";
            ctx.fillRect(screenX, screenY, wall.width, wall.height);
            ctx.strokeStyle = "#8B4513";
            ctx.lineWidth = 3;
            ctx.strokeRect(screenX, screenY, wall.width, wall.height);
          }

          ctx.restore();
        }
      }

      function drawFloatingVendors() {
        for (let vendor of floatingVendors) {
          // Update position
          vendor.x += vendor.vx;
          vendor.y += vendor.vy;

          // Bounce off world boundaries
          if (
            vendor.x - vendor.radius < 50 ||
            vendor.x + vendor.radius > WORLD_WIDTH - 50
          ) {
            vendor.vx *= -1;
          }
          if (
            vendor.y - vendor.radius < 50 ||
            vendor.y + vendor.radius > WORLD_HEIGHT - 50
          ) {
            vendor.vy *= -1;
          }

          const screenX = vendor.x - camera.x;
          const screenY = vendor.y - camera.y;

          // Only draw if on screen
          if (
            screenX < -100 ||
            screenX > canvas.width + 100 ||
            screenY < -100 ||
            screenY > canvas.height + 100
          ) {
            continue;
          }

          // Draw vendor boat
          ctx.save();

          // Wake effect
          ctx.globalAlpha = 0.3;
          ctx.fillStyle = "#FFFFFF";
          ctx.beginPath();
          ctx.ellipse(
            screenX,
            screenY + 5,
            vendor.radius + 5,
            vendor.radius,
            0,
            0,
            Math.PI * 2
          );
          ctx.fill();
          ctx.globalAlpha = 1;

          // Circular boat base
          ctx.fillStyle = "#8B4513";
          ctx.beginPath();
          ctx.ellipse(
            screenX,
            screenY,
            vendor.radius,
            vendor.radius * 0.7,
            0,
            0,
            Math.PI * 2
          );
          ctx.fill();
          ctx.strokeStyle = "#654321";
          ctx.lineWidth = 3;
          ctx.stroke();

          // Vendor emoji
          ctx.font = "40px Arial";
          ctx.fillText(vendor.emoji, screenX - 20, screenY + 10);

          ctx.restore();
        }
      }

      function drawBackground() {
        // Update time of day slowly
        timeOfDay = (Date.now() / 120000) % 1; // Full cycle every 2 minutes

        // Draw water with gradient based on time of day
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);

        if (timeOfDay < 0.25) {
          // Dawn
          gradient.addColorStop(0, "#87CEEB");
          gradient.addColorStop(0.5, "#5FB3D3");
          gradient.addColorStop(1, "#4A9DB6");
        } else if (timeOfDay < 0.5) {
          // Day
          gradient.addColorStop(0, "#5FB3D3");
          gradient.addColorStop(0.5, "#4A9DB6");
          gradient.addColorStop(1, "#2E8BA6");
        } else if (timeOfDay < 0.75) {
          // Dusk
          gradient.addColorStop(0, "#FF7F50");
          gradient.addColorStop(0.5, "#FF6B6B");
          gradient.addColorStop(1, "#8B4789");
        } else {
          // Night
          gradient.addColorStop(0, "#1a1a2e");
          gradient.addColorStop(0.5, "#16213e");
          gradient.addColorStop(1, "#0f3460");
        }

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Water ripples/waves - more visible at different times
        const waveAlpha = timeOfDay > 0.75 || timeOfDay < 0.25 ? 0.08 : 0.15;
        ctx.strokeStyle = `rgba(255, 255, 255, ${waveAlpha})`;
        ctx.lineWidth = 2;
        const time = Date.now() / 300;

        for (let y = 0; y < canvas.height; y += 60) {
          ctx.beginPath();
          for (let x = 0; x < canvas.width; x += 20) {
            const worldX = x + camera.x;
            const worldY = y + camera.y;
            const offsetY =
              y +
              Math.sin((worldX + time * 50) / 40) * 8 +
              Math.cos((worldY + time * 30) / 35) * 5;
            if (x === 0) ctx.moveTo(x, offsetY);
            else ctx.lineTo(x, offsetY);
          }
          ctx.stroke();
        }

        // Add sparkles on water during day
        if (timeOfDay > 0.25 && timeOfDay < 0.75) {
          ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
          for (let i = 0; i < 15; i++) {
            const sparkleX =
              (Math.sin(time * 2 + i * 0.7) * 0.5 + 0.5) * canvas.width;
            const sparkleY =
              (Math.cos(time * 1.5 + i * 0.9) * 0.5 + 0.5) * canvas.height;
            const sparkleSize = Math.sin(time * 3 + i) * 2 + 3;
            ctx.beginPath();
            ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      function drawLanterns() {
        // Only visible during dusk/night
        if (timeOfDay < 0.5) return;

        const nightAlpha =
          timeOfDay > 0.75 ? (timeOfDay - 0.75) * 4 : (0.75 - timeOfDay) * 4;

        for (let lantern of lanterns) {
          const screenX = lantern.x - camera.x;
          const screenY = lantern.y - camera.y;

          if (
            screenX > -100 &&
            screenX < canvas.width + 100 &&
            screenY > -100 &&
            screenY < canvas.height + 100
          ) {
            ctx.save();

            // Pulsing glow
            lantern.glow += 0.05;
            const glowSize = 40 + Math.sin(lantern.glow) * 15;

            // Outer glow
            const gradient = ctx.createRadialGradient(
              screenX,
              screenY,
              0,
              screenX,
              screenY,
              glowSize
            );
            gradient.addColorStop(
              0,
              lantern.color +
                Math.floor(nightAlpha * 100)
                  .toString(16)
                  .padStart(2, "0")
            );
            gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(screenX, screenY, glowSize, 0, Math.PI * 2);
            ctx.fill();

            // Lantern emoji
            ctx.globalAlpha = nightAlpha;
            ctx.font = "30px Arial";
            ctx.fillText("üèÆ", screenX - 15, screenY + 10);
            ctx.restore();
          }
        }
      }

      function drawMarketSigns() {
        for (let sign of marketSigns) {
          const screenX = sign.x - camera.x;
          const screenY = sign.y - camera.y;

          if (
            screenX > -100 &&
            screenX < canvas.width + 100 &&
            screenY > -100 &&
            screenY < canvas.height + 100
          ) {
            ctx.save();

            // Swaying animation
            sign.sway += 0.02;
            const swayAmount = Math.sin(sign.sway) * 0.05;

            ctx.translate(screenX, screenY);
            ctx.rotate(sign.rotation + swayAmount);

            // Sign post
            ctx.fillStyle = "#654321";
            ctx.fillRect(-3, 0, 6, 40);

            // Sign board with gradient
            const signGradient = ctx.createLinearGradient(-60, -25, 60, -25);
            signGradient.addColorStop(0, darkenColor(sign.color, 10));
            signGradient.addColorStop(0.5, sign.color);
            signGradient.addColorStop(1, darkenColor(sign.color, 10));

            ctx.fillStyle = signGradient;
            ctx.fillRect(-65, -30, 130, 35);

            // Sign border
            ctx.strokeStyle = "#FFFFFF";
            ctx.lineWidth = 3;
            ctx.strokeRect(-65, -30, 130, 35);

            // Sign text
            ctx.fillStyle = "#FFFFFF";
            ctx.font = "bold 16px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.shadowBlur = 3;
            ctx.shadowColor = "rgba(0,0,0,0.5)";
            ctx.fillText(sign.text, 0, -12);

            ctx.restore();
          }
        }
      }

      function drawDangerousObstacles() {
        for (let danger of dangerousObstacles) {
          const screenX = danger.x - camera.x;
          const screenY = danger.y - camera.y;

          if (
            screenX > -100 &&
            screenX < canvas.width + 100 &&
            screenY > -100 &&
            screenY < canvas.height + 100
          ) {
            ctx.save();

            if (danger.type === "whirlpool") {
              // Animated whirlpool
              danger.rotation += 0.1;

              // Water vortex effect
              for (let i = 0; i < 3; i++) {
                ctx.strokeStyle = `rgba(70, 130, 180, ${0.6 - i * 0.2})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(
                  screenX,
                  screenY,
                  danger.radius - i * 10,
                  danger.rotation + i,
                  danger.rotation + Math.PI * 1.5 + i
                );
                ctx.stroke();
              }

              // Center
              const centerGradient = ctx.createRadialGradient(
                screenX,
                screenY,
                0,
                screenX,
                screenY,
                15
              );
              centerGradient.addColorStop(0, "#000033");
              centerGradient.addColorStop(1, "#4682B4");
              ctx.fillStyle = centerGradient;
              ctx.beginPath();
              ctx.arc(screenX, screenY, 15, 0, Math.PI * 2);
              ctx.fill();
            } else if (danger.type === "debris") {
              // Floating debris (logs, barrels)
              ctx.translate(screenX, screenY);
              ctx.rotate(danger.rotation);

              // Shadow
              ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
              ctx.fillRect(
                -danger.radius - 5,
                5,
                danger.radius * 2,
                danger.radius * 1.5
              );

              // Debris body
              const debrisGradient = ctx.createLinearGradient(
                -danger.radius,
                0,
                danger.radius,
                0
              );
              debrisGradient.addColorStop(0, "#654321");
              debrisGradient.addColorStop(0.5, "#8B4513");
              debrisGradient.addColorStop(1, "#654321");
              ctx.fillStyle = debrisGradient;
              ctx.fillRect(
                -danger.radius,
                -danger.radius * 0.7,
                danger.radius * 2,
                danger.radius * 1.4
              );

              // Wood texture
              ctx.strokeStyle = "#3D2817";
              ctx.lineWidth = 2;
              for (let i = -danger.radius; i < danger.radius; i += 8) {
                ctx.beginPath();
                ctx.moveTo(i, -danger.radius * 0.7);
                ctx.lineTo(i, danger.radius * 0.7);
                ctx.stroke();
              }

              // Warning symbol
              ctx.fillStyle = "#FF0000";
              ctx.font = "bold 20px Arial";
              ctx.textAlign = "center";
              ctx.fillText("‚ö†Ô∏è", 0, 5);
            } else if (danger.type === "fire") {
              // Floating fire hazard
              danger.intensity = (danger.intensity || 0) + 0.1;

              // Fire glow
              const fireGradient = ctx.createRadialGradient(
                screenX,
                screenY,
                0,
                screenX,
                screenY,
                danger.radius + 10
              );
              fireGradient.addColorStop(0, "rgba(255, 100, 0, 0.8)");
              fireGradient.addColorStop(0.5, "rgba(255, 50, 0, 0.4)");
              fireGradient.addColorStop(1, "rgba(255, 0, 0, 0)");
              ctx.fillStyle = fireGradient;
              ctx.beginPath();
              ctx.arc(screenX, screenY, danger.radius + 10, 0, Math.PI * 2);
              ctx.fill();

              // Animated flames
              ctx.font = "40px Arial";
              for (let i = 0; i < 3; i++) {
                const flameY =
                  screenY - 15 + Math.sin(danger.intensity + i) * 8;
                const flameX = screenX + (i - 1) * 15;
                ctx.fillText("üî•", flameX, flameY);
              }
            }

            ctx.restore();
          }
        }
      }

      function drawSpecialItems() {
        for (let item of specialItems) {
          if (!item.collected) {
            const screenX = item.x - camera.x;
            const screenY = item.y - camera.y;

            if (
              screenX > -50 &&
              screenX < canvas.width + 50 &&
              screenY > -50 &&
              screenY < canvas.height + 50
            ) {
              ctx.save();

              // Pulsing effect
              item.pulseOffset += 0.08;
              const pulse = Math.sin(item.pulseOffset) * 10;
              const scale = 1 + Math.sin(item.pulseOffset) * 0.2;

              // Glow
              ctx.shadowBlur = 25;
              ctx.shadowColor = "#FFD700";

              // Draw item
              ctx.font = `${40 * scale}px Arial`;
              ctx.fillText(item.type, screenX - 20, screenY + pulse + 10);

              ctx.restore();
            }
          }
        }
      }

      function drawBoatTrail() {
        // Add current position to trail
        if (gameActive && !gamePaused) {
          boatTrail.push({
            x: boat.x,
            y: boat.y,
            life: 1,
          });

          // Limit trail length
          if (boatTrail.length > 20) {
            boatTrail.shift();
          }
        }

        // Draw trail
        for (let i = 0; i < boatTrail.length; i++) {
          const point = boatTrail[i];
          point.life -= 0.05;

          if (point.life > 0) {
            const screenX = point.x - camera.x;
            const screenY = point.y - camera.y;

            ctx.fillStyle = `rgba(255, 255, 255, ${point.life * 0.3})`;
            ctx.beginPath();
            ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Remove dead trail points
        boatTrail = boatTrail.filter((p) => p.life > 0);
      }

      function updateWeather() {
        weatherChangeTimer++;

        // Change weather every 20 seconds
        if (weatherChangeTimer > 1200) {
          weatherChangeTimer = 0;
          const rand = Math.random();
          if (rand < 0.7) {
            weatherEffect = "clear";
          } else {
            weatherEffect = "rain";
            // Create initial raindrops
            for (let i = 0; i < 100; i++) {
              raindrops.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                speed: 5 + Math.random() * 5,
                length: 10 + Math.random() * 10,
              });
            }
          }
        }

        // Update raindrops
        if (weatherEffect === "rain") {
          // Add new raindrops
          if (raindrops.length < 150) {
            for (let i = 0; i < 3; i++) {
              raindrops.push({
                x: Math.random() * canvas.width,
                y: -20,
                speed: 5 + Math.random() * 5,
                length: 10 + Math.random() * 10,
              });
            }
          }

          // Update positions
          raindrops.forEach((drop) => {
            drop.y += drop.speed;
            drop.x -= 2; // Slight angle
          });

          // Remove off-screen raindrops
          raindrops = raindrops.filter(
            (drop) => drop.y < canvas.height + 20 && drop.x > -20
          );
        } else {
          // Clear raindrops when weather changes
          raindrops = [];
        }
      }

      function drawWeather() {
        if (weatherEffect === "rain") {
          ctx.strokeStyle = "rgba(174, 194, 224, 0.5)";
          ctx.lineWidth = 1;

          raindrops.forEach((drop) => {
            ctx.beginPath();
            ctx.moveTo(drop.x, drop.y);
            ctx.lineTo(drop.x - 2, drop.y + drop.length);
            ctx.stroke();
          });

          // Overlay for rain ambiance
          ctx.fillStyle = "rgba(100, 120, 150, 0.05)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      }

      function checkWallCollision(nextX, nextY) {
        if (ghostMode) return false;

        for (let wall of walls) {
          if (
            nextX + boat.width / 2 > wall.x &&
            nextX - boat.width / 2 < wall.x + wall.width &&
            nextY + boat.height / 2 > wall.y &&
            nextY - boat.height / 2 < wall.y + wall.height
          ) {
            return true;
          }
        }
        return false;
      }

      function checkVendorCollision() {
        if (ghostMode) return false;

        for (let vendor of floatingVendors) {
          const dist = Math.sqrt(
            (boat.x - vendor.x) ** 2 + (boat.y - vendor.y) ** 2
          );
          if (dist < boat.radius + vendor.radius) {
            return true;
          }
        }
        return false;
      }

      function drawMinimap() {
        minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);

        const scaleX = minimapCanvas.width / WORLD_WIDTH;
        const scaleY = minimapCanvas.height / WORLD_HEIGHT;

        // Draw background
        minimapCtx.fillStyle = "#5FB3D3";
        minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);

        // Draw walls
        minimapCtx.fillStyle = "#654321";
        for (let wall of walls) {
          minimapCtx.fillRect(
            wall.x * scaleX,
            wall.y * scaleY,
            Math.max(2, wall.width * scaleX),
            Math.max(2, wall.height * scaleY)
          );
        }

        // Draw vendors
        minimapCtx.fillStyle = "#FF6B6B";
        for (let vendor of floatingVendors) {
          minimapCtx.beginPath();
          minimapCtx.arc(
            vendor.x * scaleX,
            vendor.y * scaleY,
            Math.max(2, vendor.radius * scaleX),
            0,
            Math.PI * 2
          );
          minimapCtx.fill();
        }

        // Draw food items
        minimapCtx.fillStyle = "#FFD700";
        for (let food of foods) {
          if (!food.collected) {
            minimapCtx.fillRect(food.x * scaleX - 1, food.y * scaleY - 1, 3, 3);
          }
        }

        // Draw viewport rectangle
        minimapCtx.strokeStyle = "#FFFFFF";
        minimapCtx.lineWidth = 2;
        minimapCtx.strokeRect(
          camera.x * scaleX,
          camera.y * scaleY,
          canvas.width * scaleX,
          canvas.height * scaleY
        );

        // Draw boat
        minimapCtx.fillStyle = "#00FF00";
        minimapCtx.shadowBlur = 5;
        minimapCtx.shadowColor = "#00FF00";
        minimapCtx.beginPath();
        minimapCtx.arc(boat.x * scaleX, boat.y * scaleY, 5, 0, Math.PI * 2);
        minimapCtx.fill();
        minimapCtx.shadowBlur = 0;
      }

      function createParticles(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) {
          particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 5,
            vy: (Math.random() - 0.5) * 5,
            size: Math.random() * 5 + 2,
            color: color,
            life: 1,
          });
        }
      }

      function updateParticles() {
        particles = particles.filter((p) => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.2; // gravity
          p.life -= 0.02;

          if (p.life > 0) {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
            return true;
          }
          return false;
        });
      }

      function showFloatingText(text, x, y, color = "#FFD700") {
        const textElement = document.createElement("div");
        textElement.className = "float-text";
        textElement.textContent = text;
        textElement.style.left = x + "px";
        textElement.style.top = y + "px";
        textElement.style.color = color;
        document.getElementById("gameContainer").appendChild(textElement);

        setTimeout(() => textElement.remove(), 1000);
      }

      function drawWaves() {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
        ctx.lineWidth = 2;
        for (let y = 0; y < canvas.height; y += 40) {
          ctx.beginPath();
          for (let x = 0; x < canvas.width; x += 20) {
            ctx.lineTo(x, y + Math.sin((x + Date.now() / 200) / 20) * 5);
          }
          ctx.stroke();
        }
      }

      function checkCollision(food) {
        return (
          boat.x - boat.width / 2 < food.x + food.width &&
          boat.x + boat.width / 2 > food.x &&
          boat.y < food.y + food.height &&
          boat.y + boat.height > food.y
        );
      }

      function activatePowerUp(powerUp) {
        const now = Date.now();

        switch (powerUp.effect) {
          case "time":
            timeLeft += 15;
            showFloatingText("+15s Time!", boat.x, boat.y - 30, "#00FFFF");
            playSound("powerup");
            break;
          case "speed":
            activePowerUp = "speed";
            powerUpEndTime = now + powerUp.duration;
            boat.speed = boat.baseSpeed * 2;
            speedBoostCount++;
            showFloatingText("Speed Boost!", boat.x, boat.y - 30, "#00FF00");
            playSound("powerup");
            break;
          case "multiplier":
            activePowerUp = "multiplier";
            powerUpEndTime = now + powerUp.duration;
            scoreMultiplier = 2;
            showFloatingText("2x Points!", boat.x, boat.y - 30, "#FFD700");
            playSound("powerup");
            break;
          case "ghost":
            activePowerUp = "ghost";
            powerUpEndTime = now + powerUp.duration;
            ghostMode = true;
            showFloatingText("Ghost Mode!", boat.x, boat.y - 30, "#9370DB");
            playSound("powerup");
            break;
        }

        updatePowerUpIndicator();
      }

      function updatePowerUpIndicator() {
        const indicator = document.getElementById("powerUpIndicator");
        if (activePowerUp && Date.now() < powerUpEndTime) {
          const remaining = Math.ceil((powerUpEndTime - Date.now()) / 1000);
          if (activePowerUp === "speed") {
            indicator.textContent = `üöÄ ${remaining}s`;
            indicator.style.color = "#FFD700";
          } else if (activePowerUp === "multiplier") {
            indicator.textContent = `‚ú® ${remaining}s`;
            indicator.style.color = "#FF1493";
          } else if (activePowerUp === "ghost") {
            indicator.textContent = `üëª ${remaining}s`;
            indicator.style.color = "#9370DB";
          }
        } else {
          indicator.textContent = "";
          if (activePowerUp) {
            // Power-up expired
            if (activePowerUp === "speed") {
              boat.speed = boat.baseSpeed;
            } else if (activePowerUp === "multiplier") {
              scoreMultiplier = 1;
            } else if (activePowerUp === "ghost") {
              ghostMode = false;
            }
            activePowerUp = null;
          }
        }
      }

      function updateTimeBar() {
        const timeBarFill = document.getElementById("timeBarFill");
        const percentage = (timeLeft / 30) * 100;
        timeBarFill.style.width = percentage + "%";

        // Change color based on time remaining
        if (percentage > 50) {
          timeBarFill.className = "";
        } else if (percentage > 25) {
          timeBarFill.className = "warning";
        } else {
          timeBarFill.className = "danger";
        }
      }

      function nextLevel() {
        currentLevel++;
        timeLeft += 30;
        foodsInLevel = Math.min(15 + currentLevel * 2, 30);

        // Bonus for completing level
        const levelBonus = currentLevel * 100;
        score += levelBonus;
        showFloatingText(
          `Level ${currentLevel}! +${levelBonus}`,
          canvas.width / 2,
          canvas.height / 2,
          "#FFD700"
        );

        boat.x = 150;
        boat.y = 150;

        initGame();
        playSound("powerup");
      }

      function checkLevelComplete() {
        const uncollected = foods.filter((f) => !f.collected).length;
        if (uncollected === 0) {
          nextLevel();
        }
      }

      function updateCombo() {
        combo++;
        clearTimeout(comboTimer);

        const comboDiv = document.getElementById("combo");
        comboDiv.style.display = "block";
        comboDiv.textContent = `üî• Combo: ${combo}x`;

        // Reset combo after 3 seconds of no collection
        comboTimer = setTimeout(() => {
          if (combo >= 5) perfectCatches++;
          combo = 0;
          comboDiv.style.display = "none";
        }, 3000);
      }

      // Simple sound effects using Web Audio API
      let audioContext;
      function initAudio() {
        try {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
        } catch (e) {
          console.log("Web Audio API not supported");
        }
      }

      let backgroundMusic = null;
      let ambientWater = null;

      function playSound(type) {
        if (!audioContext) return;

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        switch (type) {
          case "collect":
            // Pleasant chime sound
            oscillator.frequency.value = 523.25; // C5
            oscillator.type = "sine";
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + 0.15
            );
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);

            // Add a second note for harmony
            const osc2 = audioContext.createOscillator();
            const gain2 = audioContext.createGain();
            osc2.connect(gain2);
            gain2.connect(audioContext.destination);
            osc2.frequency.value = 659.25; // E5
            osc2.type = "sine";
            gain2.gain.setValueAtTime(0.2, audioContext.currentTime + 0.05);
            gain2.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + 0.2
            );
            osc2.start(audioContext.currentTime + 0.05);
            osc2.stop(audioContext.currentTime + 0.2);
            break;
          case "powerup":
            // Ascending arpeggio
            [0, 0.1, 0.2].forEach((delay, i) => {
              const osc = audioContext.createOscillator();
              const gain = audioContext.createGain();
              osc.connect(gain);
              gain.connect(audioContext.destination);
              osc.frequency.value = [523.25, 659.25, 783.99][i]; // C5, E5, G5
              osc.type = "triangle";
              gain.gain.setValueAtTime(0.2, audioContext.currentTime + delay);
              gain.gain.exponentialRampToValueAtTime(
                0.01,
                audioContext.currentTime + delay + 0.2
              );
              osc.start(audioContext.currentTime + delay);
              osc.stop(audioContext.currentTime + delay + 0.2);
            });
            break;
          case "gameover":
            // Descending sad notes
            [0, 0.2, 0.4].forEach((delay, i) => {
              const osc = audioContext.createOscillator();
              const gain = audioContext.createGain();
              osc.connect(gain);
              gain.connect(audioContext.destination);
              osc.frequency.value = [440, 349.23, 293.66][i]; // A4, F4, D4
              osc.type = "sawtooth";
              gain.gain.setValueAtTime(0.2, audioContext.currentTime + delay);
              gain.gain.exponentialRampToValueAtTime(
                0.01,
                audioContext.currentTime + delay + 0.4
              );
              osc.start(audioContext.currentTime + delay);
              osc.stop(audioContext.currentTime + delay + 0.4);
            });
            break;
        }
      }

      function startAmbientSounds() {
        if (!audioContext) return;

        // Ambient water sounds (gentle waves)
        if (!ambientWater) {
          ambientWater = audioContext.createOscillator();
          const waterGain = audioContext.createGain();
          const filter = audioContext.createBiquadFilter();

          ambientWater.type = "sine";
          ambientWater.frequency.value = 100;
          filter.type = "lowpass";
          filter.frequency.value = 300;

          ambientWater.connect(filter);
          filter.connect(waterGain);
          waterGain.connect(audioContext.destination);

          waterGain.gain.setValueAtTime(0.02, audioContext.currentTime);
          ambientWater.start();

          // Modulate frequency for wave effect
          setInterval(() => {
            if (ambientWater && gameActive) {
              ambientWater.frequency.setValueAtTime(
                100 + Math.sin(Date.now() / 1000) * 20,
                audioContext.currentTime
              );
            }
          }, 100);
        }

        // Background music (pentatonic melody)
        if (!backgroundMusic) {
          playBackgroundMusic();
        }
      }

      function playBackgroundMusic() {
        if (!audioContext || !gameActive) return;

        const pentatonic = [523.25, 587.33, 659.25, 783.99, 880]; // C5, D5, E5, G5, A5
        const noteDuration = 0.8;
        const noteGap = 0.4;

        function playNote(freq, delay) {
          setTimeout(() => {
            if (!gameActive) return;

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            osc.type = "triangle";
            osc.frequency.value = freq;
            filter.type = "lowpass";
            filter.frequency.value = 2000;

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);

            gain.gain.setValueAtTime(0.05, audioContext.currentTime);
            gain.gain.linearRampToValueAtTime(
              0.08,
              audioContext.currentTime + 0.1
            );
            gain.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + noteDuration
            );

            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + noteDuration);
          }, delay);
        }

        // Play a simple melody pattern
        const melody = [0, 2, 4, 2, 1, 0, 1, 2];
        melody.forEach((noteIndex, i) => {
          playNote(pentatonic[noteIndex], i * (noteDuration + noteGap) * 1000);
        });

        // Loop the music
        setTimeout(() => {
          if (gameActive) playBackgroundMusic();
        }, melody.length * (noteDuration + noteGap) * 1000);
      }

      function stopAmbientSounds() {
        if (ambientWater) {
          ambientWater.stop();
          ambientWater = null;
        }
        backgroundMusic = null;
      }

      function updateGame() {
        if (!gameActive || gamePaused) {
          if (gameActive && gamePaused) {
            requestAnimationFrame(updateGame);
          }
          return;
        }

        // Clear and draw background
        drawBackground();

        // Update camera to follow boat
        updateCamera();

        // Update weather effects
        updateWeather();

        // Draw decorative elements first
        drawWaterLilies();
        drawLanterns();
        drawWalls();
        drawMarketSigns();
        drawFloatingVendors();
        drawDangerousObstacles();
        drawSpecialItems();
        drawBoatTrail();

        // Store previous position
        const prevX = boat.x;
        const prevY = boat.y;
        let nextX = boat.x;
        let nextY = boat.y;

        // Keyboard controls with collision detection
        if (keys["ArrowLeft"]) {
          nextX -= boat.speed;
        }
        if (keys["ArrowRight"]) {
          nextX += boat.speed;
        }
        if (keys["ArrowUp"]) {
          nextY -= boat.speed;
        }
        if (keys["ArrowDown"]) {
          nextY += boat.speed;
        }

        // Check wall collision
        if (!checkWallCollision(nextX, boat.y)) {
          boat.x = nextX;
        }
        if (!checkWallCollision(boat.x, nextY)) {
          boat.y = nextY;
        }

        // Keep boat within world bounds
        boat.x = Math.max(50, Math.min(WORLD_WIDTH - 50, boat.x));
        boat.y = Math.max(50, Math.min(WORLD_HEIGHT - 50, boat.y));

        // Touch controls with world coordinates
        if (isTouching) {
          const targetX = touchStartX + camera.x;
          const targetY = touchStartY + camera.y;

          const dx = targetX - boat.x;
          const dy = targetY - boat.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance > 5) {
            const moveX = (dx / distance) * boat.speed;
            const moveY = (dy / distance) * boat.speed;

            nextX = boat.x + moveX;
            nextY = boat.y + moveY;

            if (!checkWallCollision(nextX, boat.y)) {
              boat.x = nextX;
            }
            if (!checkWallCollision(boat.x, nextY)) {
              boat.y = nextY;
            }
          }
        }

        // Check vendor collision
        if (checkVendorCollision()) {
          // Push boat back
          boat.x = prevX;
          boat.y = prevY;

          // Small penalty
          if (!ghostMode && Math.random() < 0.1) {
            score = Math.max(0, score - 5);
            const screenX = boat.x - camera.x;
            const screenY = boat.y - camera.y;
            showFloatingText("-5", screenX, screenY - 30, "#FF0000");
          }
        } else if (floatingVendors.length > 0 && !ghostMode) {
          collisionsAvoided++;
        }

        // Check dangerous obstacle collision
        if (!ghostMode) {
          for (let danger of dangerousObstacles) {
            const dist = Math.sqrt(
              (boat.x - danger.x) ** 2 + (boat.y - danger.y) ** 2
            );
            if (dist < danger.radius + boat.width / 2) {
              // Push boat back
              boat.x = prevX;
              boat.y = prevY;

              // Penalties based on danger type
              let penalty = 0;
              let message = "";

              if (danger.type === "whirlpool") {
                penalty = 15;
                message = "-15 Whirlpool!";
                // Slow boat temporarily
                boat.speed = Math.max(1, boat.speed * 0.7);
                setTimeout(() => {
                  boat.speed = boat.baseSpeed;
                }, 1000);
              } else if (danger.type === "debris") {
                penalty = 10;
                message = "-10 Debris!";
              } else if (danger.type === "fire") {
                penalty = 20;
                message = "-20 Fire!";
                timeLeft = Math.max(0, timeLeft - 2);
              }

              score = Math.max(0, score - penalty);
              const screenX = boat.x - camera.x;
              const screenY = boat.y - camera.y;
              showFloatingText(message, screenX, screenY - 40, "#FF0000");
              playSound("gameover");

              // Visual feedback
              createParticles(
                boat.x,
                boat.y,
                danger.type === "fire" ? "#FF4500" : "#4682B4",
                20
              );
              break;
            }
          }
        }

        // Update moving debris
        for (let danger of dangerousObstacles) {
          if (danger.type === "debris" && danger.vx !== undefined) {
            danger.x += danger.vx;
            danger.y += danger.vy;
            danger.rotation += 0.02;

            // Bounce off world edges
            if (danger.x < 50 || danger.x > WORLD_WIDTH - 50) danger.vx *= -1;
            if (danger.y < 50 || danger.y > WORLD_HEIGHT - 50) danger.vy *= -1;
          }
        }

        // Draw and check food collection
        foods.forEach((food) => {
          if (!food.collected) {
            drawFood(food);

            if (checkCollision(food)) {
              food.collected = true;

              if (food.isPowerUp) {
                activatePowerUp(food.type);
                createParticles(food.x, food.y, food.type.color, 15);
              } else {
                const points = food.type.points * scoreMultiplier;
                const comboBonus = Math.floor(combo * 3);
                const totalPoints = points + comboBonus;

                score += totalPoints;
                totalCollected++;
                collectedFoods[food.type.name] =
                  (collectedFoods[food.type.name] || 0) + 1;

                updateCombo();

                createParticles(food.x, food.y, food.type.color, 8);

                let displayText = `+${totalPoints}`;
                if (comboBonus > 0) displayText += ` (${combo}x)`;
                showFloatingText(displayText, food.x, food.y, food.type.color);

                playSound("collect");
              }

              updateUI();
              checkLevelComplete();
            }
          }
        });

        // Check special item collection
        specialItems.forEach((item) => {
          if (!item.collected) {
            const dist = Math.sqrt(
              (boat.x - item.x) ** 2 + (boat.y - item.y) ** 2
            );
            if (dist < 40) {
              item.collected = true;
              score += item.points;

              const screenX = item.x - camera.x;
              const screenY = item.y - camera.y;
              createParticles(screenX, screenY, "#FFD700", 20);
              showFloatingText(
                `+${item.points} BONUS!`,
                screenX,
                screenY,
                "#FFD700"
              );
              playSound("powerup");
              updateUI();
            }
          }
        });

        updateParticles();
        updatePowerUpIndicator();
        updateTimeBar();
        drawBoat();
        drawWeather(); // Draw weather effects on top
        drawMinimap();
        requestAnimationFrame(updateGame);
      }

      function updateUI() {
        document.getElementById("score").textContent = `Score: ${score}`;
        document.getElementById("timer").textContent = `Time: ${timeLeft}s`;
        document.getElementById("level").textContent = `Level: ${currentLevel}`;
        const remaining = foods.filter((f) => !f.collected).length;
        document.getElementById(
          "collected"
        ).textContent = `Remaining: ${remaining}/${foodsInLevel}`;
        document.getElementById(
          "highScore"
        ).textContent = `High Score: ${highScore}`;
      }

      function calculateAchievements() {
        const achievements = [];

        if (currentLevel >= 5) {
          achievements.push({
            name: "üèÜ Maze Master",
            desc: "Reached Level 5+",
          });
        } else if (currentLevel >= 3) {
          achievements.push({
            name: "‚≠ê Maze Explorer",
            desc: "Reached Level 3+",
          });
        }

        if (totalCollected >= 50) {
          achievements.push({
            name: "üçâ Master Collector",
            desc: "Collected 50+ items",
          });
        }

        if (perfectCatches >= 3) {
          achievements.push({
            name: "üî• Combo Master",
            desc: "Got 3+ perfect combos (5+ streak)",
          });
        }

        if (speedBoostCount >= 5) {
          achievements.push({
            name: "üöÄ Speed Demon",
            desc: "Used 5+ speed boosts",
          });
        }

        if (collisionsAvoided >= 100) {
          achievements.push({
            name: "üéØ Precision Navigator",
            desc: "Avoided 100+ obstacle hits",
          });
        }

        if (score >= 1000) {
          achievements.push({
            name: "üíé High Scorer",
            desc: "Scored 1000+ points",
          });
        }

        if (Object.keys(collectedFoods).length === 10) {
          achievements.push({
            name: "üåü Variety Expert",
            desc: "Collected all food types",
          });
        }

        return achievements;
      }

      function endGame() {
        gameActive = false;
        stopAmbientSounds();
        playSound("gameover");

        // Update high score
        let isNewHighScore = false;
        if (score > highScore) {
          highScore = score;
          localStorage.setItem("floatingMarketHighScore", highScore);
          isNewHighScore = true;
        }

        const gameOverDiv = document.getElementById("gameOver");
        document.getElementById(
          "finalScore"
        ).textContent = `Final Score: ${score} | Level: ${currentLevel} | Items: ${totalCollected}`;

        if (isNewHighScore) {
          document.getElementById("highScoreMessage").innerHTML =
            '<span style="color: #FFD700; font-size: 24px;">üéâ NEW HIGH SCORE! üéâ</span>';
        } else {
          document.getElementById("highScoreMessage").textContent = "";
        }

        let foodListHTML = "<h3>üìä Game Statistics:</h3>";
        foodListHTML += `<p>Levels Completed: ${currentLevel - 1}</p>`;
        foodListHTML += `<p>Total Items Collected: ${totalCollected}</p>`;
        foodListHTML += `<p>Longest Combo: ${Math.max(
          ...(combo > 0 ? [combo] : [0])
        )}</p>`;

        foodListHTML += "<h3>Items Collected:</h3>";
        if (Object.keys(collectedFoods).length > 0) {
          for (let [name, count] of Object.entries(collectedFoods)) {
            const foodType = foodItems.find((f) => f.name === name);
            foodListHTML += `<div class="food-name">${foodType.emoji} ${name}: ${count}</div>`;
          }
        } else {
          foodListHTML += "<p>No items collected</p>";
        }
        document.getElementById("foodList").innerHTML = foodListHTML;

        // Display achievements
        const achievements = calculateAchievements();
        let achievementsHTML = "<h3>üèÖ Achievements</h3>";
        if (achievements.length > 0) {
          achievements.forEach((ach) => {
            achievementsHTML += `<div class="achievement unlocked">${ach.name}<br><small>${ach.desc}</small></div>`;
          });
        } else {
          achievementsHTML += "<p>No achievements earned this round</p>";
        }
        document.getElementById("achievements").innerHTML = achievementsHTML;

        gameOverDiv.style.display = "block";
      }

      function startGame() {
        document.getElementById("startScreen").style.display = "none";
        initAudio();
        resetGame();
        gameActive = true;
        gameStarted = true;
        startAmbientSounds();
        updateGame();
        startTimer();
      }

      function resetGame() {
        score = 0;
        timeLeft = 90;
        currentLevel = 1;
        collectedFoods = {};
        boat.x = 150;
        boat.y = 150;
        boat.speed = boat.baseSpeed;
        camera.x = 0;
        camera.y = 0;
        combo = 0;
        totalCollected = 0;
        perfectCatches = 0;
        speedBoostCount = 0;
        collisionsAvoided = 0;
        activePowerUp = null;
        scoreMultiplier = 1;
        ghostMode = false;
        particles = [];
        foodsInLevel = 15;
        document.getElementById("combo").style.display = "none";
        initGame();
        updateUI();
      }

      function restartGame() {
        document.getElementById("gameOver").style.display = "none";
        resetGame();
        gameActive = true;
        startAmbientSounds();
        updateGame();
        startTimer();
      }

      function quitToMenu() {
        gameActive = false;
        gamePaused = false;
        document.getElementById("gameOver").style.display = "none";
        document.getElementById("pauseScreen").style.display = "none";
        document.getElementById("startScreen").style.display = "flex";
        resetGame();
      }

      function togglePause() {
        if (!gameActive) return;

        gamePaused = !gamePaused;
        document.getElementById("pauseScreen").style.display = gamePaused
          ? "flex"
          : "none";
      }

      function startTimer() {
        const timer = setInterval(() => {
          if (gameActive && !gamePaused) {
            timeLeft--;
            updateUI();
            if (timeLeft <= 0) {
              clearInterval(timer);
              endGame();
            }
          }
          if (!gameActive) {
            clearInterval(timer);
          }
        }, 1000);
      }

      // Event Listeners
      document.addEventListener("keydown", (e) => {
        if (e.key === "p" || e.key === "P" || e.key === "Escape") {
          togglePause();
          e.preventDefault();
          return;
        }

        if (!gamePaused) {
          keys[e.key] = true;
          if (
            ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(
              e.key
            )
          ) {
            e.preventDefault();
          }
        }
      });

      document.addEventListener("keyup", (e) => {
        keys[e.key] = false;
      });

      // Touch controls for mobile
      canvas.addEventListener("touchstart", (e) => {
        if (!gameActive || gamePaused) return;
        e.preventDefault();

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        const touch = e.touches[0];
        touchStartX = (touch.clientX - rect.left) * scaleX;
        touchStartY = (touch.clientY - rect.top) * scaleY;
        isTouching = true;
      });

      canvas.addEventListener("touchmove", (e) => {
        if (!gameActive || gamePaused || !isTouching) return;
        e.preventDefault();

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        const touch = e.touches[0];
        touchStartX = (touch.clientX - rect.left) * scaleX;
        touchStartY = (touch.clientY - rect.top) * scaleY;
      });

      canvas.addEventListener("touchend", (e) => {
        e.preventDefault();
        isTouching = false;
      });

      canvas.addEventListener("touchcancel", (e) => {
        e.preventDefault();
        isTouching = false;
      });

      // Mouse controls as alternative
      canvas.addEventListener("mousedown", (e) => {
        if (!gameActive || gamePaused) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        touchStartX = (e.clientX - rect.left) * scaleX;
        touchStartY = (e.clientY - rect.top) * scaleY;
        isTouching = true;
      });

      canvas.addEventListener("mousemove", (e) => {
        if (!gameActive || gamePaused || !isTouching) return;

        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        touchStartX = (e.clientX - rect.left) * scaleX;
        touchStartY = (e.clientY - rect.top) * scaleY;
      });

      canvas.addEventListener("mouseup", () => {
        isTouching = false;
      });

      canvas.addEventListener("mouseleave", () => {
        isTouching = false;
      });

      // Initialize
      updateUI();
      document.getElementById(
        "highScore"
      ).textContent = `High Score: ${highScore}`;
    </script>
  </body>
</html>
