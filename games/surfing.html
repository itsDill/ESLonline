<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced Wave Rider Simulator</title>
    <style>
      /* Modern CSS Reset */
      *,
      *::before,
      *::after {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #87ceeb 0%, #4682b4 100%);
        scroll-behavior: smooth;
        -webkit-overflow-scrolling: touch;
      }

      body {
        width: 100%;
        min-height: 100%;
        overflow: hidden;
        touch-action: manipulation;
        font-family: "Courier New", monospace;
      }

      #surfCanvas {
        display: block;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(
          to bottom,
          #87ceeb 0%,
          #4682b4 50%,
          #1e3c72 100%
        );
      }

      .title {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: rgba(255, 255, 255, 0.95);
        font-family: "Courier New", monospace;
        font-size: clamp(18px, 3vw, 28px);
        text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
        z-index: 100;
        background: rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        padding: 12px 24px;
        border-radius: 15px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        text-align: center;
      }

      .wave-controls {
        position: fixed;
        top: 100px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 15px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.15);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        padding: 20px;
        border-radius: 20px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        min-width: 200px;
      }

      .surfer-controls {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 15px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.15);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        padding: 15px 25px;
        border-radius: 20px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        flex-wrap: wrap;
        justify-content: center;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: center;
      }

      .control-label {
        color: rgba(255, 255, 255, 0.9);
        font-size: 12px;
        font-weight: bold;
        text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        text-align: center;
        min-width: 80px;
      }

      button {
        background: rgba(255, 255, 255, 0.15);
        color: #fff;
        border: 2px solid rgba(255, 255, 255, 0.3);
        padding: 12px 20px;
        cursor: pointer;
        border-radius: 12px;
        font-family: "Courier New", monospace;
        font-size: 14px;
        font-weight: bold;
        transition: all 0.3s ease;
        min-width: 120px;
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      }

      button:hover {
        background: rgba(255, 255, 255, 0.25);
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        border-color: rgba(255, 255, 255, 0.5);
      }

      button:active {
        transform: translateY(0);
      }

      input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 140px;
        height: 8px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        outline: none;
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: linear-gradient(145deg, #fff, #e0e0e0);
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.8);
      }

      .wave-info {
        position: fixed;
        top: 100px;
        left: 20px;
        color: rgba(255, 255, 255, 0.9);
        background: rgba(0, 0, 0, 0.15);
        padding: 15px;
        border-radius: 15px;
        font-size: 12px;
        z-index: 100;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      }

      .score-display {
        position: fixed;
        top: 200px;
        left: 20px;
        color: rgba(255, 255, 255, 0.9);
        background: rgba(0, 0, 0, 0.15);
        padding: 15px;
        border-radius: 15px;
        font-size: 12px;
        z-index: 100;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      }

      @media (max-width: 768px) {
        .wave-controls {
          right: 10px;
          padding: 15px;
          min-width: 160px;
        }

        .surfer-controls {
          bottom: 10px;
          padding: 12px 18px;
          gap: 10px;
        }

        button {
          padding: 10px 16px;
          min-width: 100px;
          font-size: 12px;
        }

        input[type="range"] {
          width: 100px;
        }

        .wave-info,
        .score-display {
          left: 10px;
          padding: 12px;
          font-size: 11px;
        }
      }
    </style>
  </head>
  <body>
    <h1 class="title">üèÑ‚Äç‚ôÇÔ∏è Advanced Wave Rider Simulator</h1>

    <div class="wave-info">
      <div>Wave Height: <span id="heightDisplay">2.0m</span></div>
      <div>Wave Speed: <span id="speedDisplay">1.0x</span></div>
      <div>Turbulence: <span id="turbulenceDisplay">30%</span></div>
      <div>Surfer Speed: <span id="surferSpeedDisplay">0.0 m/s</span></div>
      <div>Wave Type: <span id="waveTypeDisplay">Gentle</span></div>
    </div>

    <div class="score-display">
      <div>Score: <span id="scoreDisplay">0</span></div>
      <div>Ride Time: <span id="rideTimeDisplay">0.0s</span></div>
      <div>Max Speed: <span id="maxSpeedDisplay">0.0 m/s</span></div>
      <div>Tricks: <span id="tricksDisplay">0</span></div>
      <div>Status: <span id="statusDisplay">Ready</span></div>
      <div>Wave Power: <span id="wavePowerDisplay">0%</span></div>
    </div>

    <div class="wave-controls">
      <div class="control-group">
        <label class="control-label">Wave Height</label>
        <input type="range" id="waveHeight" min="30" max="120" value="60" />
      </div>
      <div class="control-group">
        <label class="control-label">Wave Speed</label>
        <input type="range" id="waveSpeed" min="5" max="25" value="12" />
      </div>
      <div class="control-group">
        <label class="control-label">Turbulence</label>
        <input type="range" id="waveTurbulence" min="0" max="50" value="15" />
      </div>
      <div class="control-group">
        <label class="control-label">Wave Period</label>
        <input type="range" id="wavePeriod" min="1" max="6" value="3" />
      </div>
      <div class="control-group">
        <label class="control-label">Break Intensity</label>
        <input type="range" id="breakIntensity" min="0" max="100" value="50" />
      </div>
    </div>

    <canvas id="surfCanvas"></canvas>

    <div class="surfer-controls">
      <button id="btnMoveLeft">‚óÄ Left</button>
      <button id="btnMoveRight">Right ‚ñ∂</button>
      <button id="btnStandUp">üèÑ‚Äç‚ôÇÔ∏è Stand</button>
      <button id="btnLieDown">üèä‚Äç‚ôÇÔ∏è Paddle</button>
      <button id="btnTrick">ü§∏‚Äç‚ôÇÔ∏è Trick</button>
      <button id="btnReset">Reset</button>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const canvas = document.getElementById("surfCanvas");
        const ctx = canvas.getContext("2d");

        // Set canvas to full window size
        function resizeCanvas() {
          const dpr = window.devicePixelRatio || 1;
          canvas.width = window.innerWidth * dpr;
          canvas.height = window.innerHeight * dpr;
          canvas.style.width = window.innerWidth + "px";
          canvas.style.height = window.innerHeight + "px";
          ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform before scaling
          ctx.scale(dpr, dpr);
        }
        resizeCanvas();

        let resizeTimeout;
        window.addEventListener("resize", () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            resizeCanvas();
            initWavePoints();
          }, 100);
        });

        // Improved wave configuration with breaking simulation
        const waveConfig = {
          baseLevel: window.innerHeight * 0.65,
          height: 60,
          speed: 0.012,
          turbulence: 15,
          period: 3,
          breakIntensity: 50,
          time: 0,
          points: [],
          breakingPoints: [],
          numPoints: 150,
          smoothingFactor: 0.85,
          consistency: 0.9,
          breakingThreshold: 0.4, // When wave starts to break (0-1)
        };

        // Enhanced surfer object with wave riding physics
        const surfer = {
          x: window.innerWidth * 0.3,
          y: waveConfig.baseLevel,
          width: 20,
          height: 30,
          standing: false,
          velocity: { x: 0, y: 0 },
          acceleration: { x: 0, y: 0 },
          rotation: 0,
          targetRotation: 0,
          mass: 1,
          dragCoeff: 0.96,
          gravity: 0.3,
          bounce: 0.4,
          speed: 0,
          maxSpeed: 0,
          waveForce: 0,
          inWater: true,
          trail: [],
          score: 0,
          rideTime: 0,
          tricks: 0,
          isRiding: false,
          trickCooldown: 0,
          lastTrickTime: 0,
          optimalPosition: 0, // 0-1 where 0 is top of wave, 1 is bottom
          rideQuality: 0, // How well the surfer is positioned on wave (0-1)
          wavePower: 0, // Current wave power at surfer position (0-1)
          lastWaveHeight: 0, // For calculating wave power
        };

        // Initialize wave points
        function initWavePoints() {
          waveConfig.points = [];
          waveConfig.breakingPoints = [];
          for (let i = 0; i <= waveConfig.numPoints; i++) {
            waveConfig.points.push({
              x: (i / waveConfig.numPoints) * window.innerWidth,
              y: waveConfig.baseLevel,
              targetY: waveConfig.baseLevel,
              velocity: 0,
              breaking: false,
              breakProgress: 0,
              foam: 0,
            });
          }
        }
        initWavePoints();

        // Improved wave generation with breaking simulation
        function updateWave() {
          waveConfig.time += waveConfig.speed;

          // Calculate target wave shape first
          for (let i = 0; i < waveConfig.points.length; i++) {
            const x = waveConfig.points[i].x;
            const normalizedX = x / window.innerWidth;

            let targetY = waveConfig.baseLevel;

            // Primary wave system - more predictable
            const mainWave =
              Math.sin(
                normalizedX * Math.PI * waveConfig.period + waveConfig.time
              ) * waveConfig.height;
            targetY += mainWave;

            // Secondary harmonics for realistic shape
            const harmonic2 =
              Math.sin(
                normalizedX * Math.PI * waveConfig.period * 2 +
                  waveConfig.time * 0.7
              ) *
              (waveConfig.height * 0.3);
            const harmonic3 =
              Math.sin(
                normalizedX * Math.PI * waveConfig.period * 4 +
                  waveConfig.time * 0.5
              ) *
              (waveConfig.height * 0.15);

            targetY += harmonic2 + harmonic3;

            // Controlled turbulence
            const turbulenceAmount =
              (waveConfig.turbulence / 100) * waveConfig.height * 0.2;
            const turbulence =
              (Math.sin(normalizedX * 20 + waveConfig.time * 3) +
                Math.cos(normalizedX * 15 + waveConfig.time * 2.3)) *
              turbulenceAmount *
              0.5;
            targetY += turbulence;

            waveConfig.points[i].targetY = targetY;
          }

          // Smooth the wave using spring physics and detect breaking sections
          for (let i = 0; i < waveConfig.points.length; i++) {
            const point = waveConfig.points[i];
            const prevPoint = i > 0 ? waveConfig.points[i - 1] : point;
            const nextPoint =
              i < waveConfig.points.length - 1
                ? waveConfig.points[i + 1]
                : point;

            // Calculate slope to determine breaking sections
            const slope = nextPoint.y - prevPoint.y;
            const steepness = Math.abs(slope) / waveConfig.height;

            // Spring force towards target
            const springForce = (point.targetY - point.y) * 0.15;
            point.velocity += springForce;

            // Damping
            point.velocity *= 0.92;

            // Update position
            point.y += point.velocity;

            // Neighbor smoothing for consistency
            if (i > 0 && i < waveConfig.points.length - 1) {
              const avgY = (prevPoint.y + nextPoint.y) / 2;
              const smoothingForce =
                (avgY - point.y) * (1 - waveConfig.consistency);
              point.y += smoothingForce * 0.1;
            }

            // Breaking wave simulation
            if (steepness > waveConfig.breakingThreshold) {
              point.breaking = true;
              point.breakProgress = Math.min(
                1,
                point.breakProgress +
                  (steepness - waveConfig.breakingThreshold) * 0.05
              );
              point.foam = Math.min(
                1,
                point.foam + (steepness - waveConfig.breakingThreshold) * 0.02
              );
            } else {
              point.breaking = false;
              point.breakProgress = Math.max(0, point.breakProgress - 0.01);
              point.foam = Math.max(0, point.foam - 0.005);
            }
          }
        }

        // Get wave data at specific x position with interpolation
        function getWaveDataAtX(x) {
          const normalizedX = Math.max(0, Math.min(1, x / window.innerWidth));
          const floatIndex = normalizedX * (waveConfig.points.length - 1);
          const index = Math.floor(floatIndex);
          const t = floatIndex - index;

          if (index >= waveConfig.points.length - 1) {
            const lastPoint = waveConfig.points[waveConfig.points.length - 1];
            return {
              height: lastPoint.y,
              slope: 0,
              velocity: lastPoint.velocity,
              breaking: lastPoint.breaking,
              breakProgress: lastPoint.breakProgress,
              foam: lastPoint.foam,
            };
          }

          // Linear interpolation
          const y1 = waveConfig.points[index].y;
          const y2 = waveConfig.points[index + 1].y;
          const height = y1 + (y2 - y1) * t;

          // Calculate slope
          const slope = y2 - y1;

          // Average velocity
          const v1 = waveConfig.points[index].velocity;
          const v2 = waveConfig.points[index + 1].velocity;
          const velocity = v1 + (v2 - v1) * t;

          // Breaking and foam
          const breaking =
            waveConfig.points[index].breaking ||
            waveConfig.points[index + 1].breaking;
          const breakProgress =
            waveConfig.points[index].breakProgress * (1 - t) +
            waveConfig.points[index + 1].breakProgress * t;
          const foam =
            waveConfig.points[index].foam * (1 - t) +
            waveConfig.points[index + 1].foam * t;

          return { height, slope, velocity, breaking, breakProgress, foam };
        }

        // Enhanced surfer physics with automatic wave riding
        function updateSurfer() {
          const waveData = getWaveDataAtX(surfer.x);
          const waveHeight = waveData.height;
          const waveSlope = waveData.slope;

          // Calculate wave power (energy) at current position
          const waveHeightChange = waveHeight - surfer.lastWaveHeight;
          surfer.wavePower = Math.min(
            1,
            Math.max(0, Math.abs(waveHeightChange) * 0.5 + waveData.foam * 0.5)
          );
          surfer.lastWaveHeight = waveHeight;

          // Reset acceleration
          surfer.acceleration.x = 0;
          surfer.acceleration.y = surfer.gravity;

          // Check if surfer is in water
          surfer.inWater = surfer.y > waveHeight - 20;

          if (surfer.inWater) {
            // Buoyancy force
            const submersion = Math.max(0, surfer.y - (waveHeight - 10));
            const buoyancy = -submersion * 0.2;
            surfer.acceleration.y += buoyancy;

            // Wave energy transfer - automatic riding when positioned correctly
            if (surfer.standing) {
              // Calculate optimal position on wave (0 = top, 1 = bottom)
              const wavePhase =
                ((surfer.x / window.innerWidth) * waveConfig.period * Math.PI +
                  waveConfig.time) %
                (Math.PI * 2);
              surfer.optimalPosition = (Math.sin(wavePhase) + 1) / 2; // 0-1

              // Calculate how well positioned the surfer is on the wave
              const positionDiff = Math.abs(surfer.optimalPosition - 0.7); // Best position is around 0.7
              surfer.rideQuality = 1 - positionDiff * 1.5;

              // Automatic riding physics when well positioned
              if (surfer.rideQuality > 0.3) {
                // Gravity-based riding - no need to paddle when positioned right
                const gravityForce = waveSlope * 0.01 * surfer.rideQuality;
                surfer.acceleration.x += gravityForce;

                // Additional wave push when in the pocket
                if (surfer.rideQuality > 0.6) {
                  const wavePush =
                    waveData.velocity * 0.02 * surfer.rideQuality;
                  surfer.acceleration.x += wavePush;
                }
              }

              // Breaking wave boost
              if (waveData.breaking && surfer.rideQuality > 0.5) {
                const breakBoost =
                  waveData.breakProgress *
                  0.03 *
                  (waveConfig.breakIntensity / 50);
                surfer.acceleration.x += breakBoost;
              }
            }

            // Water drag
            surfer.velocity.x *= surfer.dragCoeff;
            surfer.velocity.y *= 0.94;

            // Improved riding detection
            if (
              surfer.standing &&
              surfer.speed > 1 &&
              surfer.rideQuality > 0.3
            ) {
              surfer.isRiding = true;
              surfer.rideTime += 1 / 60; // Assuming 60fps
              // Score based on speed, ride quality and wave power
              surfer.score += Math.floor(
                surfer.speed * 0.1 * surfer.rideQuality * surfer.wavePower
              );
            } else {
              surfer.isRiding = false;
            }
          } else {
            // Air physics
            surfer.velocity.x *= 0.998;
            surfer.isRiding = false;
          }

          // Update velocities
          surfer.velocity.x += surfer.acceleration.x;
          surfer.velocity.y += surfer.acceleration.y;

          // Speed limits
          surfer.velocity.x = Math.max(-8, Math.min(8, surfer.velocity.x));
          surfer.velocity.y = Math.max(-10, Math.min(10, surfer.velocity.y));

          // Update position
          surfer.x += surfer.velocity.x;
          surfer.y += surfer.velocity.y;

          // Surface collision
          if (surfer.y > waveHeight - 5) {
            surfer.y = waveHeight - 5;
            if (surfer.velocity.y > 0) {
              surfer.velocity.y *= -surfer.bounce;
            }
          }

          // Rotation based on slope and speed
          surfer.targetRotation =
            waveSlope * 0.003 +
            surfer.velocity.x * 0.02 -
            surfer.acceleration.x * 0.01;
          surfer.rotation += (surfer.targetRotation - surfer.rotation) * 0.15;

          // Calculate speed
          surfer.speed = Math.sqrt(
            surfer.velocity.x * surfer.velocity.x +
              surfer.velocity.y * surfer.velocity.y
          );
          surfer.maxSpeed = Math.max(surfer.maxSpeed, surfer.speed);

          // Update trail
          surfer.trail.push({ x: surfer.x, y: surfer.y, alpha: 1 });
          if (surfer.trail.length > 12) surfer.trail.shift();
          surfer.trail.forEach((point) => (point.alpha *= 0.9));

          // Keep on screen
          if (surfer.x < 0) {
            surfer.x = 0;
            surfer.velocity.x = Math.abs(surfer.velocity.x) * 0.3;
          } else if (surfer.x > window.innerWidth) {
            surfer.x = window.innerWidth;
            surfer.velocity.x = -Math.abs(surfer.velocity.x) * 0.3;
          }

          // Update trick cooldown
          if (surfer.trickCooldown > 0) surfer.trickCooldown--;
        }

        // Enhanced wave rendering with breaking effects
        function drawWave() {
          // Water gradient
          const waterGradient = ctx.createLinearGradient(
            0,
            waveConfig.baseLevel - 50,
            0,
            window.innerHeight
          );
          waterGradient.addColorStop(0, "rgba(64, 164, 223, 0.7)");
          waterGradient.addColorStop(0.4, "rgba(28, 107, 160, 0.85)");
          waterGradient.addColorStop(1, "rgba(15, 45, 100, 1)");

          // Draw water body
          ctx.beginPath();
          ctx.moveTo(0, window.innerHeight);

          for (let i = 0; i < waveConfig.points.length; i++) {
            ctx.lineTo(waveConfig.points[i].x, waveConfig.points[i].y);
          }

          ctx.lineTo(window.innerWidth, window.innerHeight);
          ctx.closePath();
          ctx.fillStyle = waterGradient;
          ctx.fill();

          // Draw wave surface with breaking effects
          ctx.beginPath();
          ctx.moveTo(0, waveConfig.points[0].y);

          for (let i = 1; i < waveConfig.points.length; i++) {
            const point = waveConfig.points[i];
            const prevPoint = waveConfig.points[i - 1];

            if (point.breaking && point.breakProgress > 0.3) {
              // Draw breaking wave section with foam
              const breakHeight =
                point.breakProgress * 30 * (waveConfig.breakIntensity / 50);
              const foamHeight = point.foam * 15;

              // Draw the breaking wave curve
              const midX = (point.x + prevPoint.x) / 2;
              const midY = (point.y + prevPoint.y) / 2 - breakHeight;

              ctx.quadraticCurveTo(midX, midY, point.x, point.y);

              // Add foam particles
              if (Math.random() < point.foam * 0.3) {
                createSpray(
                  point.x,
                  point.y - 5,
                  point.foam * 2,
                  waveConfig.breakIntensity / 50
                );
              }
            } else {
              // Normal wave section
              ctx.lineTo(point.x, point.y);
            }
          }

          ctx.strokeStyle = `rgba(255, 255, 255, 0.6)`;
          ctx.lineWidth = 2;
          ctx.stroke();

          // Add foam on steep sections
          for (let i = 1; i < waveConfig.points.length - 1; i++) {
            const point = waveConfig.points[i];
            const slope = Math.abs(
              waveConfig.points[i + 1].y - waveConfig.points[i - 1].y
            );

            if (slope > 8 || point.foam > 0.1) {
              const foamIntensity = Math.min(0.8, slope / 20 + point.foam);
              ctx.fillStyle = `rgba(255, 255, 255, ${foamIntensity})`;
              ctx.beginPath();

              // Draw foam patches
              if (point.breaking) {
                // Larger foam for breaking waves
                ctx.ellipse(
                  point.x,
                  point.y + 3,
                  6 + point.foam * 10,
                  3 + point.foam * 5,
                  0,
                  0,
                  Math.PI * 2
                );
              } else {
                // Small bubbles for steep sections
                ctx.arc(
                  point.x,
                  point.y + 3,
                  2 + foamIntensity * 3,
                  0,
                  Math.PI * 2
                );
              }

              ctx.fill();
            }
          }
        }

        // Enhanced surfer rendering with trick animations
        function drawSurfer() {
          const waveData = getWaveDataAtX(surfer.x);

          // Draw trail with color based on ride quality
          if (surfer.trail.length > 1 && surfer.isRiding) {
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(surfer.trail[0].x, surfer.trail[0].y);

            for (let i = 1; i < surfer.trail.length; i++) {
              const alpha = surfer.trail[i].alpha * 0.6;
              const hue = 40 + surfer.rideQuality * 20; // Yellow to green based on quality
              ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${alpha})`;
              ctx.lineTo(surfer.trail[i].x, surfer.trail[i].y);
              ctx.stroke();
            }

            ctx.globalAlpha = 1;
          }

          ctx.save();
          ctx.translate(surfer.x, surfer.y);
          ctx.rotate(surfer.rotation);

          // Add glow effect when riding well
          if (surfer.isRiding && surfer.rideQuality > 0.6) {
            ctx.shadowBlur = 15 + surfer.rideQuality * 10;
            ctx.shadowColor = `hsla(${
              40 + surfer.rideQuality * 20
            }, 100%, 50%, 0.5)`;
          }

          const animPhase = Date.now() * 0.008;
          const bobAmount = surfer.inWater ? Math.sin(animPhase) * 0.5 : 0;

          if (surfer.standing) {
            // Surfboard with color based on speed
            const boardHue = Math.min(60, surfer.speed * 10);
            ctx.fillStyle = `hsl(${boardHue}, 80%, 70%)`;
            ctx.fillRect(-20, -2, 40, 6);
            ctx.fillStyle = "#4A90E2";
            ctx.fillRect(-16, -1, 10, 3);

            // Body with dynamic pose
            const leanAngle = surfer.velocity.x * 0.05;
            ctx.save();
            ctx.rotate(leanAngle);

            // Torso with color based on ride quality
            const torsoHue = 10 + surfer.rideQuality * 20;
            ctx.fillStyle = `hsl(${torsoHue}, 100%, 50%)`;
            ctx.fillRect(-8, -25 + bobAmount, 16, 20);

            // Head
            ctx.fillStyle = "#FFDBAC";
            ctx.beginPath();
            ctx.arc(0, -30 + bobAmount, 6, 0, Math.PI * 2);
            ctx.fill();

            // Arms - spread based on speed for balance
            const armSpread = Math.min(12, surfer.speed * 1.5);
            ctx.fillStyle = `hsl(${torsoHue}, 100%, 50%)`;
            ctx.fillRect(-12 - armSpread, -22 + bobAmount, 5, 12);
            ctx.fillRect(7 + armSpread, -22 + bobAmount, 5, 12);

            // Legs
            ctx.fillRect(-6, -8 + bobAmount, 5, 12);
            ctx.fillRect(1, -8 + bobAmount, 5, 12);

            ctx.restore();
          } else {
            // Lying down (paddling)
            const paddlePhase = Math.sin(animPhase * 4) * 0.2;

            // Surfboard
            ctx.fillStyle = "#FFFFFF";
            ctx.fillRect(-25, -4, 50, 8);
            ctx.fillStyle = "#4A90E2";
            ctx.fillRect(-20, -2, 12, 4);

            // Body
            ctx.fillStyle = "#FF6B35";
            ctx.fillRect(-22, -8 + bobAmount, 38, 12);

            // Head
            ctx.fillStyle = "#FFDBAC";
            ctx.beginPath();
            ctx.arc(-28, 0 + bobAmount, 5, 0, Math.PI * 2);
            ctx.fill();

            // Paddling arms
            ctx.fillStyle = "#FF6B35";
            ctx.fillRect(-18, -6 + bobAmount + paddlePhase, 10, 3);
            ctx.fillRect(8, -6 + bobAmount - paddlePhase, 10, 3);
          }

          // Add splash effects when moving fast
          if (surfer.speed > 2.5 && surfer.inWater) {
            for (let i = 0; i < 2; i++) {
              ctx.fillStyle = `rgba(255, 255, 255, ${0.5 - i * 0.2})`;
              ctx.beginPath();
              ctx.arc(
                -15 - i * 3,
                8 + Math.random() * 3,
                1.5 - i * 0.3,
                0,
                Math.PI * 2
              );
              ctx.fill();
            }
          }

          ctx.restore();
        }

        // Particle system for enhanced effects
        const particles = [];
        const sprayParticles = [];

        function createSplash(x, y, intensity = 1) {
          for (let i = 0; i < 5 * intensity; i++) {
            particles.push({
              x: x + (Math.random() - 0.5) * 20,
              y: y + (Math.random() - 0.5) * 10,
              vx: (Math.random() - 0.5) * 4,
              vy: -Math.random() * 3 - 1,
              size: Math.random() * 3 + 1,
              life: 1,
              decay: 0.02 + Math.random() * 0.02,
            });
          }
        }

        function createSpray(x, y, intensity = 1, power = 1) {
          for (let i = 0; i < 3 * intensity; i++) {
            sprayParticles.push({
              x: x + (Math.random() - 0.5) * 10 * power,
              y: y + (Math.random() - 0.5) * 5 * power,
              vx: (Math.random() - 0.5) * 2 * power,
              vy: -Math.random() * 4 * power,
              size: Math.random() * 2 + 1,
              life: 1,
              decay: 0.01 + Math.random() * 0.01,
              alpha: 0.7 + Math.random() * 0.3,
            });
          }
        }

        function updateParticles() {
          // Update splash particles
          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.1; // gravity
            p.life -= p.decay;

            if (p.life <= 0) {
              particles.splice(i, 1);
            }
          }

          // Update spray particles
          for (let i = sprayParticles.length - 1; i >= 0; i--) {
            const p = sprayParticles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.05; // lighter gravity
            p.vx *= 0.98; // air resistance
            p.life -= p.decay;

            if (p.life <= 0) {
              sprayParticles.splice(i, 1);
            }
          }
        }

        function drawParticles() {
          // Draw splash particles
          particles.forEach((p) => {
            ctx.save();
            ctx.globalAlpha = p.life;
            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          });

          // Draw spray particles
          sprayParticles.forEach((p) => {
            ctx.save();
            ctx.globalAlpha = p.life * p.alpha;
            ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          });
        }

        // Main animation loop with enhanced effects
        function enhancedAnimate() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Dynamic sky with time-based color shifts
          const timeOfDay = (Math.sin(waveConfig.time * 0.001) + 1) * 0.5;
          const energy = waveConfig.height / 120;

          const skyGradient = ctx.createLinearGradient(
            0,
            0,
            0,
            window.innerHeight * 0.6
          );
          skyGradient.addColorStop(
            0,
            `rgba(${135 + timeOfDay * 50}, ${206 - timeOfDay * 50}, 235, ${
              0.4 + energy * 0.3
            })`
          );
          skyGradient.addColorStop(
            0.5,
            `rgba(${70 + timeOfDay * 30}, ${130 - timeOfDay * 30}, 180, ${
              0.6 + energy * 0.2
            })`
          );
          skyGradient.addColorStop(
            1,
            `rgba(${30 + timeOfDay * 20}, ${60 - timeOfDay * 20}, 114, 0.8)`
          );

          ctx.fillStyle = skyGradient;
          ctx.fillRect(0, 0, window.innerWidth, window.innerHeight * 0.6);

          updateWave();
          updateSurfer();
          updateParticles();

          // Create splash effects when surfing fast
          if (surfer.speed > 3 && surfer.inWater && Math.random() < 0.3) {
            createSplash(surfer.x - 10, surfer.y + 10, surfer.speed * 0.2);
          }

          drawWave();
          drawParticles();
          drawSurfer();
          updateDisplays();

          requestAnimationFrame(enhancedAnimate);
        }

        // Update display values
        function updateDisplays() {
          document.getElementById("heightDisplay").textContent =
            (waveConfig.height / 30 + 0.5).toFixed(1) + "m";
          document.getElementById("speedDisplay").textContent =
            (waveConfig.speed * 80).toFixed(1) + "x";
          document.getElementById("turbulenceDisplay").textContent =
            waveConfig.turbulence + "%";
          document.getElementById("surferSpeedDisplay").textContent =
            (surfer.speed * 0.4).toFixed(1) + " m/s";
          document.getElementById("wavePowerDisplay").textContent =
            Math.floor(surfer.wavePower * 100) + "%";

          // Wave type
          let waveType = "Gentle";
          if (waveConfig.height > 70) waveType = "Moderate";
          if (waveConfig.height > 90) waveType = "Large";
          if (waveConfig.height > 110) waveType = "Huge";
          document.getElementById("waveTypeDisplay").textContent = waveType;

          // Score display
          document.getElementById("scoreDisplay").textContent = Math.floor(
            surfer.score
          );
          document.getElementById("rideTimeDisplay").textContent =
            surfer.rideTime.toFixed(1) + "s";
          document.getElementById("maxSpeedDisplay").textContent =
            (surfer.maxSpeed * 0.4).toFixed(1) + " m/s";
          document.getElementById("tricksDisplay").textContent = surfer.tricks;

          // Status
          let status = "Ready";
          if (surfer.isRiding) {
            if (surfer.rideQuality > 0.7) status = "Perfect Ride!";
            else if (surfer.rideQuality > 0.5) status = "Great Ride!";
            else status = "Riding";
          } else if (surfer.inWater) {
            status = surfer.standing ? "Balancing" : "Paddling";
          } else {
            status = "Airborne";
          }
          document.getElementById("statusDisplay").textContent = status;
        }

        // Control event handlers
        const controls = {
          waveHeight: document.getElementById("waveHeight"),
          waveSpeed: document.getElementById("waveSpeed"),
          waveTurbulence: document.getElementById("waveTurbulence"),
          wavePeriod: document.getElementById("wavePeriod"),
          breakIntensity: document.getElementById("breakIntensity"),
          btnMoveLeft: document.getElementById("btnMoveLeft"),
          btnMoveRight: document.getElementById("btnMoveRight"),
          btnStandUp: document.getElementById("btnStandUp"),
          btnLieDown: document.getElementById("btnLieDown"),
          btnTrick: document.getElementById("btnTrick"),
          btnReset: document.getElementById("btnReset"),
        };

        // Wave control handlers
        controls.waveHeight.addEventListener("input", (e) => {
          waveConfig.height = parseInt(e.target.value);
        });

        controls.waveSpeed.addEventListener("input", (e) => {
          waveConfig.speed = parseInt(e.target.value) * 0.001;
        });

        controls.waveTurbulence.addEventListener("input", (e) => {
          waveConfig.turbulence = parseInt(e.target.value);
        });

        controls.wavePeriod.addEventListener("input", (e) => {
          waveConfig.period = parseInt(e.target.value);
        });

        controls.breakIntensity.addEventListener("input", (e) => {
          waveConfig.breakIntensity = parseInt(e.target.value);
        });

        // Surfer control handlers
        controls.btnMoveLeft.addEventListener("click", () => {
          surfer.velocity.x -= 0.8;
        });

        controls.btnMoveRight.addEventListener("click", () => {
          surfer.velocity.x += 0.8;
        });

        controls.btnStandUp.addEventListener("click", () => {
          if (surfer.inWater && surfer.speed > 0.5) {
            surfer.standing = true;
            surfer.score += 10;
          }
        });

        controls.btnLieDown.addEventListener("click", () => {
          surfer.standing = false;
        });

        controls.btnTrick.addEventListener("click", () => {
          if (
            surfer.standing &&
            surfer.isRiding &&
            surfer.trickCooldown === 0 &&
            surfer.speed > 2
          ) {
            surfer.tricks++;
            surfer.score += Math.floor(surfer.speed * 25 * surfer.rideQuality);
            surfer.trickCooldown = 120; // 2 seconds at 60fps

            // Add trick rotation effect
            surfer.targetRotation += Math.PI * 0.5;

            // Visual feedback
            setTimeout(() => {
              surfer.targetRotation = 0;
            }, 500);

            // Create splash effect for tricks
            createSplash(surfer.x, surfer.y + 5, 2);
          }
        });

        controls.btnReset.addEventListener("click", () => {
          surfer.x = window.innerWidth * 0.3;
          surfer.y = waveConfig.baseLevel;
          surfer.velocity = { x: 0, y: 0 };
          surfer.standing = false;
          surfer.rotation = 0;
          surfer.targetRotation = 0;
          surfer.speed = 0;
          surfer.maxSpeed = 0;
          surfer.trail = [];
          surfer.score = 0;
          surfer.rideTime = 0;
          surfer.tricks = 0;
          surfer.isRiding = false;
          surfer.trickCooldown = 0;
          surfer.optimalPosition = 0;
          surfer.rideQuality = 0;
          surfer.wavePower = 0;
        });

        // Keyboard controls
        const keys = {};

        document.addEventListener("keydown", (e) => {
          keys[e.key.toLowerCase()] = true;

          switch (e.key.toLowerCase()) {
            case "a":
            case "arrowleft":
              surfer.velocity.x -= 0.5;
              break;
            case "d":
            case "arrowright":
              surfer.velocity.x += 0.5;
              break;
            case "w":
            case "arrowup":
            case " ":
              if (surfer.inWater && surfer.speed > 0.5) {
                surfer.standing = true;
                surfer.score += 10;
              }
              e.preventDefault();
              break;
            case "s":
            case "arrowdown":
              surfer.standing = false;
              break;
            case "t":
              if (
                surfer.standing &&
                surfer.isRiding &&
                surfer.trickCooldown === 0 &&
                surfer.speed > 2
              ) {
                surfer.tricks++;
                surfer.score += Math.floor(
                  surfer.speed * 25 * surfer.rideQuality
                );
                surfer.trickCooldown = 120;
                surfer.targetRotation += Math.PI * 0.5;
                createSplash(surfer.x, surfer.y + 5, 2);
                setTimeout(() => {
                  surfer.targetRotation = 0;
                }, 500);
              }
              break;
            case "r":
              controls.btnReset.click();
              break;
          }
        });

        document.addEventListener("keyup", (e) => {
          keys[e.key.toLowerCase()] = false;
        });

        // Touch controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener("touchstart", (e) => {
          e.preventDefault();
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
        });

        canvas.addEventListener("touchmove", (e) => {
          e.preventDefault();
        });

        canvas.addEventListener("touchend", (e) => {
          e.preventDefault();
          const touchEndX = e.changedTouches[0].clientX;
          const touchEndY = e.changedTouches[0].clientY;

          const deltaX = touchEndX - touchStartX;
          const deltaY = touchEndY - touchStartY;

          if (Math.abs(deltaX) > Math.abs(deltaY)) {
            // Horizontal swipe
            if (deltaX > 30) {
              surfer.velocity.x += 0.8; // Swipe right
            } else if (deltaX < -30) {
              surfer.velocity.x -= 0.8; // Swipe left
            }
          } else {
            // Vertical swipe
            if (deltaY < -30) {
              // Swipe up - stand up
              if (surfer.inWater && surfer.speed > 0.5) {
                surfer.standing = true;
                surfer.score += 10;
              }
            } else if (deltaY > 30) {
              // Swipe down - lie down
              surfer.standing = false;
            }
          }

          // Tap for tricks
          if (Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10) {
            if (
              surfer.standing &&
              surfer.isRiding &&
              surfer.trickCooldown === 0 &&
              surfer.speed > 2
            ) {
              surfer.tricks++;
              surfer.score += Math.floor(
                surfer.speed * 25 * surfer.rideQuality
              );
              surfer.trickCooldown = 120;
              surfer.targetRotation += Math.PI * 0.5;
              createSplash(surfer.x, surfer.y + 5, 2);
              setTimeout(() => {
                surfer.targetRotation = 0;
              }, 500);
            }
          }
        });

        // Start the simulation
        enhancedAnimate();

        // Add instructions panel
        const instructionsPanel = document.createElement("div");
        instructionsPanel.innerHTML = `
          <div style="position: fixed; bottom: 20px; right: 20px; background: rgba(0,0,0,0.15); backdrop-filter: blur(12px); padding: 15px; border-radius: 15px; color: white; font-size: 11px; max-width: 200px; border: 1px solid rgba(255,255,255,0.2);">
            <strong>Controls:</strong><br>
            A/D or ‚Üê/‚Üí: Move<br>
            W/‚Üë/Space: Stand up<br>
            S/‚Üì: Lie down<br>
            T: Perform trick<br>
            R: Reset<br>
            <br><strong>Tips:</strong><br>
            - Position yourself on the wave face<br>
            - Bigger waves break more<br>
            - Ride the breaking section for speed<br>
            <br><strong>Mobile:</strong><br>
            Swipe to move<br>
            Swipe up: Stand<br>
            Tap: Trick
          </div>
        `;
        document.body.appendChild(instructionsPanel);

        console.log("üèÑ‚Äç‚ôÇÔ∏è Advanced Wave Simulator Ready!");
        console.log("Use WASD/Arrow keys or touch controls to surf!");
      });
    </script>
  </body>
</html>
