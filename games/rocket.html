<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>üöµ‚Äç‚ôÇÔ∏è Endless Downhill Mountain Bike</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(
          135deg,
          #87ceeb 0%,
          #4682b4 50%,
          #2f4f4f 100%
        );
        font-family: "Arial", sans-serif;
        overflow: hidden;
        user-select: none;
      }

      #gameCanvas {
        display: block;
        background: linear-gradient(
          to bottom,
          #87ceeb 0%,
          #98d8e8 30%,
          #5a9fd4 60%,
          #2f5f2f 100%
        );
      }

      .ui-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 100;
      }

      .hud {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 10px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.3);
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }

      .speedometer {
        position: absolute;
        top: 20px;
        right: 20px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 50%;
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255, 255, 255, 0.3);
        text-align: center;
        min-width: 120px;
        min-height: 120px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }

      .controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 12px 20px;
        border-radius: 20px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.3);
        text-align: center;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }

      .game-over {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        background: rgba(0, 0, 0, 0.9);
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        backdrop-filter: blur(15px);
        border: 2px solid rgba(255, 255, 255, 0.3);
        display: none;
        pointer-events: all;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }

      .restart-btn {
        background: linear-gradient(45deg, #4caf50, #45a049);
        color: white;
        border: none;
        padding: 12px 25px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        margin-top: 15px;
        transition: all 0.3s ease;
      }

      .restart-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
      }

      @media (max-width: 768px) {
        .hud,
        .speedometer {
          font-size: 12px;
          padding: 10px;
        }

        .speedometer {
          min-width: 90px;
          min-height: 90px;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>

    <div class="ui-overlay">
      <div class="hud">
        <div>Distance: <span id="distance">0</span>m</div>
        <div>Score: <span id="score">0</span></div>
        <div>Altitude: <span id="altitude">2500</span>m</div>
        <div>Time: <span id="gameTime">0:00</span></div>
      </div>

      <div class="speedometer">
        <div style="font-size: 24px; font-weight: bold" id="speed">0</div>
        <div style="font-size: 12px">km/h</div>
        <div style="font-size: 10px; margin-top: 5px">
          Health: <span id="health">100</span>%
        </div>
      </div>

      <div class="controls">
        üöµ‚Äç‚ôÇÔ∏è A/D: Steer | W/S: Brake/Boost | Space: Jump | Mobile: Touch controls
      </div>

      <div class="game-over" id="gameOverScreen">
        <h2>üèÅ Ride Complete!</h2>
        <div style="margin: 15px 0">
          <div>Final Distance: <span id="finalDistance">0</span>m</div>
          <div>Final Score: <span id="finalScore">0</span></div>
          <div>Max Speed: <span id="maxSpeed">0</span> km/h</div>
          <div>Ride Time: <span id="finalTime">0:00</span></div>
        </div>
        <button class="restart-btn" onclick="restartGame()">
          üöµ‚Äç‚ôÇÔ∏è Ride Again
        </button>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Set canvas size
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();

      window.addEventListener("resize", resizeCanvas);

      // Game state
      const game = {
        running: true,
        paused: false,
        score: 0,
        distance: 0,
        gameTime: 0,
        maxSpeed: 0,
        startTime: Date.now(),
        cameraZ: 0,
      };

      // Player (bike and rider)
      const player = {
        x: 0, // Centered at 0
        y: 0,
        z: 0,
        velocityX: 0,
        velocityY: 0,
        velocityZ: 12, // Forward speed
        maxSpeed: 30,
        acceleration: 0.3,
        friction: 0.96,
        jumpPower: 0,
        onGround: true,
        health: 100,
        rotation: 0,
        lean: 0,
        width: 15,
        height: 25,
      };

      // Road system
      const road = {
        width: 2000,
        segments: [],
        segmentLength: 200,
        drawDistance: 300,
      };

      // Initialize road segments
      function initRoad() {
        road.segments = [];
        let curve = 0;
        let hill = 0;

        for (let i = 0; i < 1600; i++) {
          const segment = {
            index: i,
            curve: curve,
            y: hill,
            obstacles: [],
            trees: [],
          };

          // Generate curves
          curve += (Math.random() - 0.5) * 0.01;
          curve *= 0.98;

          // Generate hills
          hill += (Math.random() - 0.5) * 100;
          hill *= 0.95;

          // Add obstacles
          if (Math.random() < 0.15 && i > 20) {
            segment.obstacles.push({
              x: (Math.random() - 0.5) * road.width * 0.6,
              type: Math.random() < 0.6 ? "rock" : "tree",
              size: 0.3 + Math.random() * 0.4,
            });
          }

          // Add trees on sides
          if (Math.random() < 0.3) {
            for (let side = -1; side <= 1; side += 2) {
              segment.trees.push({
                x: side * (road.width * 0.8 + Math.random() * 400),
                size: 0.5 + Math.random() * 1.5,
              });
            }
          }

          road.segments.push(segment);
        }
      }

      // 3D projection
      function project(p, cameraX, cameraY, cameraZ, cameraDepth = 0.84) {
        const x = p.x - cameraX;
        const y = p.y - cameraY;
        const z = p.z - cameraZ;

        return {
          x: canvas.width / 2 + (((cameraDepth * x) / z) * canvas.width) / 2,
          y: canvas.height / 2 - (((cameraDepth * y) / z) * canvas.height) / 2,
          w: ((cameraDepth / z) * canvas.width) / 2,
        };
      }

      // Particle system
      const particles = [];

      function addParticle(x, y, z, vx, vy, vz, life, color) {
        particles.push({
          x: x,
          y: y,
          z: z,
          vx: vx,
          vy: vy,
          vz: vz,
          life: life,
          maxLife: life,
          color: color,
        });
      }

      function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.z += p.vz;
          p.vy += 10; // gravity
          p.life--;

          if (p.life <= 0) {
            particles.splice(i, 1);
          }
        }
      }

      // Update player physics
      function updatePlayer() {
        // Apply input
        handleInput();

        // Get current segment
        const playerSegment = Math.floor(player.z / road.segmentLength);
        const segment = road.segments[playerSegment] || {
          curve: 0,
          y: 0,
          obstacles: [],
        };

        // Apply curve force
        const speedPercent = player.velocityZ / player.maxSpeed;
        player.velocityX -=
          segment.curve *
          speedPercent *
          speedPercent *
          player.velocityZ *
          0.003;

        // Apply physics
        player.velocityX *= player.friction;
        player.x += player.velocityX;
        player.z += player.velocityZ;

        // Handle jumping
        if (player.jumpPower > 0) {
          player.jumpPower -= 1.5;
          player.y -= player.jumpPower;
          player.onGround = false;
        } else {
          const groundY = segment.y;
          if (player.y >= groundY) {
            player.y = groundY;
            player.onGround = true;
            if (player.jumpPower < -5) {
              // Hard landing particles
              for (let i = 0; i < 8; i++) {
                addParticle(
                  player.x + (Math.random() - 0.5) * 50,
                  player.y,
                  player.z,
                  (Math.random() - 0.5) * 10,
                  -Math.random() * 20 - 5,
                  (Math.random() - 0.5) * 10,
                  30 + Math.random() * 20,
                  "#8B4513"
                );
              }
              player.health -= Math.abs(player.jumpPower) * 1.5;
            }
            player.jumpPower = 0;
          } else {
            player.jumpPower -= 1.2; // Gravity
          }
        }

        // Track boundaries
        const maxX = road.width * 0.4;
        if (player.x > maxX) {
          player.x = maxX;
          player.velocityX = -Math.abs(player.velocityX) * 0.3;
          player.health -= 2;
        } else if (player.x < -maxX) {
          player.x = -maxX;
          player.velocityX = Math.abs(player.velocityX) * 0.3;
          player.health -= 2;
        }

        // Update lean and rotation
        player.lean = player.velocityX * 0.002;
        player.rotation = player.lean * 30;

        // Collision detection
        checkCollisions(segment);

        // Create dust particles when moving fast on ground
        if (player.velocityZ > 18 && player.onGround && Math.random() < 0.4) {
          for (let i = 0; i < 3; i++) {
            addParticle(
              player.x + (Math.random() - 0.5) * 30,
              player.y + 20,
              player.z - 20,
              (Math.random() - 0.5) * 8,
              -Math.random() * 5,
              (Math.random() - 0.5) * 8,
              20 + Math.random() * 15,
              "#DEB887"
            );
          }
        }

        // Update camera
        game.cameraZ = player.z - 100;

        // Update stats
        game.distance = Math.floor(player.z / 10);
        game.score += Math.floor(player.velocityZ * 0.2);
        game.maxSpeed = Math.max(
          game.maxSpeed,
          Math.floor(player.velocityZ * 3.6)
        );

        // Health regeneration
        if (player.velocityZ < 10 && player.health < 100) {
          player.health += 0.2;
        }

        // Game over condition
        if (player.health <= 0) {
          gameOver();
        }
      }

      function checkCollisions(segment) {
        segment.obstacles.forEach((obstacle, index) => {
          const dx = player.x - obstacle.x;
          const dz = player.z % road.segmentLength;
          const distance = Math.sqrt(dx * dx + dz * dz);

          if (distance < 100 + obstacle.size * 100) {
            // Collision!
            player.health -= 20;
            player.velocityZ *= 0.4;
            player.velocityX += (Math.random() - 0.5) * 15;

            // Crash particles
            for (let i = 0; i < 15; i++) {
              addParticle(
                player.x + (Math.random() - 0.5) * 50,
                player.y,
                player.z,
                (Math.random() - 0.5) * 20,
                -Math.random() * 30 - 10,
                (Math.random() - 0.5) * 20,
                40 + Math.random() * 30,
                Math.random() < 0.5 ? "#FF4444" : "#FFFF44"
              );
            }

            // Remove obstacle
            segment.obstacles.splice(index, 1);
          }
        });
      }

      // Input handling
      const keys = {};

      document.addEventListener("keydown", (e) => {
        keys[e.key.toLowerCase()] = true;

        if (e.key === " ") {
          e.preventDefault();
          if (player.onGround) {
            player.jumpPower = 25;
            player.onGround = false;
          }
        }
      });

      document.addEventListener("keyup", (e) => {
        keys[e.key.toLowerCase()] = false;
      });

      function handleInput() {
        if (!game.running) return;

        // Steering
        if (keys["a"] || keys["arrowleft"]) {
          player.velocityX -= player.acceleration;
        }
        if (keys["d"] || keys["arrowright"]) {
          player.velocityX += player.acceleration;
        }

        // Speed control
        if (keys["w"] || keys["arrowup"]) {
          player.velocityZ = Math.min(
            player.velocityZ + player.acceleration * 0.8,
            player.maxSpeed
          );
        }
        if (keys["s"] || keys["arrowdown"]) {
          player.velocityZ *= 0.92; // Brake
        }
      }

      // Touch controls
      let touchStartX = 0;
      let touchStartY = 0;

      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      });

      canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();
        const touchX = e.touches[0].clientX;
        const deltaX = (touchX - touchStartX) / canvas.width;

        player.velocityX += deltaX * 8;
        touchStartX = touchX;
      });

      canvas.addEventListener("touchend", (e) => {
        e.preventDefault();
        const touchEndY = e.changedTouches[0].clientY;
        const deltaY = touchStartY - touchEndY;

        if (deltaY > 50 && player.onGround) {
          player.jumpPower = 25;
          player.onGround = false;
        } else if (deltaY < -50) {
          player.velocityZ *= 0.85;
        }
      });

      // Render functions
      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawSky();
        drawMountains();
        drawRoad();
        drawParticles();
        drawPlayer();
      }

      function drawSky() {
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, "#87CEEB");
        gradient.addColorStop(0.3, "#98D8E8");
        gradient.addColorStop(0.7, "#5A9FD4");
        gradient.addColorStop(1, "#2F5F2F");

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Clouds
        const cloudSpeed = Date.now() * 0.00002;
        for (let i = 0; i < 6; i++) {
          const x = ((i * 300 + cloudSpeed * 200) % (canvas.width + 200)) - 100;
          const y = 50 + Math.sin(i * 2) * 40;
          const size = 40 + i * 5;

          ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
          ctx.beginPath();
          ctx.arc(x, y, size * 0.6, 0, Math.PI * 2);
          ctx.arc(x + size * 0.5, y, size * 0.8, 0, Math.PI * 2);
          ctx.arc(x + size, y, size * 0.6, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function drawMountains() {
        ctx.fillStyle = "rgba(60, 60, 100, 0.6)";
        ctx.beginPath();
        ctx.moveTo(0, canvas.height * 0.6);

        for (let i = 0; i <= canvas.width; i += 40) {
          const height =
            canvas.height *
            (0.4 + Math.sin(i * 0.008 + game.cameraZ * 0.0001) * 0.15);
          ctx.lineTo(i, height);
        }

        ctx.lineTo(canvas.width, canvas.height);
        ctx.lineTo(0, canvas.height);
        ctx.closePath();
        ctx.fill();
      }

      function drawRoad() {
        const baseSegment = Math.floor(game.cameraZ / road.segmentLength);

        // Draw road segments from far to near
        for (let n = 0; n < road.drawDistance; n++) {
          const segment = road.segments[baseSegment + n];
          if (!segment) continue;

          const segmentPercent = (n + 1) / road.drawDistance;

          // Calculate segment positions
          let curveOffset = 0;
          for (let i = 0; i <= n; i++) {
            const seg = road.segments[baseSegment + i];
            if (seg) curveOffset += seg.curve;
          }

          // Project road points
          const z1 = (baseSegment + n) * road.segmentLength;
          const z2 = (baseSegment + n + 1) * road.segmentLength;

          const p1 = project(
            { x: -road.width / 2 - curveOffset, y: segment.y, z: z1 },
            player.x,
            player.y,
            game.cameraZ
          );
          const p2 = project(
            { x: road.width / 2 - curveOffset, y: segment.y, z: z1 },
            player.x,
            player.y,
            game.cameraZ
          );

          const nextSegment = road.segments[baseSegment + n + 1] || segment;
          const nextCurveOffset = curveOffset + segment.curve;
          const p3 = project(
            { x: -road.width / 2 - nextCurveOffset, y: nextSegment.y, z: z2 },
            player.x,
            player.y,
            game.cameraZ
          );
          const p4 = project(
            { x: road.width / 2 - nextCurveOffset, y: nextSegment.y, z: z2 },
            player.x,
            player.y,
            game.cameraZ
          );

          // Skip if behind camera
          if (z1 <= game.cameraZ) continue;

          // Draw road surface
          const grassColor = `hsl(${100 + Math.sin(n * 0.3) * 20}, 60%, ${
            25 + segmentPercent * 30
          }%)`;
          const roadColor = segmentPercent > 0.6 ? "#666" : "#555";
          const lineColor = segmentPercent > 0.6 ? "#fff" : "#aaa";

          // Grass
          ctx.fillStyle = grassColor;
          ctx.fillRect(0, p1.y, canvas.width, p3.y - p1.y);

          // Road
          if (p1.y < canvas.height && p3.y > 0) {
            ctx.fillStyle = roadColor;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.lineTo(p4.x, p4.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.closePath();
            ctx.fill();

            // Road markings
            if (n % 3 === 0 && segmentPercent > 0.3) {
              ctx.strokeStyle = lineColor;
              ctx.lineWidth = Math.max(1, p1.w * 0.02);

              const centerX = (p1.x + p2.x) / 2;
              const nextCenterX = (p3.x + p4.x) / 2;

              ctx.beginPath();
              ctx.moveTo(centerX, p1.y);
              ctx.lineTo(nextCenterX, p3.y);
              ctx.stroke();
            }
          }

          // Draw obstacles
          segment.obstacles.forEach((obstacle) => {
            const obsPos = project(
              {
                x: obstacle.x - curveOffset,
                y: segment.y - obstacle.size * 100,
                z: z1,
              },
              player.x,
              player.y,
              game.cameraZ
            );

            if (obsPos.w > 0.1 && obsPos.y > 0 && obsPos.y < canvas.height) {
              const size = obsPos.w * obstacle.size * 100;

              if (obstacle.type === "rock") {
                ctx.fillStyle = "#666";
                ctx.fillRect(obsPos.x - size / 2, obsPos.y - size, size, size);
              } else {
                // Tree
                ctx.fillStyle = "#8B4513";
                ctx.fillRect(
                  obsPos.x - size * 0.1,
                  obsPos.y - size * 0.3,
                  size * 0.2,
                  size * 0.3
                );
                ctx.fillStyle = "#228B22";
                ctx.beginPath();
                ctx.arc(
                  obsPos.x,
                  obsPos.y - size * 0.6,
                  size * 0.4,
                  0,
                  Math.PI * 2
                );
                ctx.fill();
              }
            }
          });

          // Draw trees
          segment.trees.forEach((tree) => {
            const treePos = project(
              {
                x: tree.x - curveOffset,
                y: segment.y - tree.size * 100,
                z: z1,
              },
              player.x,
              player.y,
              game.cameraZ
            );

            if (
              treePos.w > 0.05 &&
              treePos.y > 0 &&
              treePos.y < canvas.height
            ) {
              const size = treePos.w * tree.size * 60;

              // Tree trunk
              ctx.fillStyle = "#8B4513";
              ctx.fillRect(
                treePos.x - size * 0.1,
                treePos.y - size * 0.4,
                size * 0.2,
                size * 0.4
              );

              // Tree foliage
              ctx.fillStyle = "#228B22";
              ctx.beginPath();
              ctx.arc(
                treePos.x,
                treePos.y - size * 0.7,
                size * 0.5,
                0,
                Math.PI * 2
              );
              ctx.fill();
            }
          });
        }
      }

      function drawParticles() {
        particles.forEach((particle) => {
          const pos = project(
            {
              x: particle.x,
              y: particle.y,
              z: particle.z,
            },
            player.x,
            player.y,
            game.cameraZ
          );

          if (pos.w > 0.01 && particle.z > game.cameraZ) {
            const alpha = particle.life / particle.maxLife;
            const size = pos.w * 8;

            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = particle.color;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, Math.max(1, size), 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        });
      }

      function drawPlayer() {
        const playerPos = project(
          { x: player.x, y: player.y - 50, z: player.z },
          player.x,
          player.y,
          game.cameraZ
        );

        if (playerPos.w <= 0) return;

        ctx.save();
        ctx.translate(playerPos.x, playerPos.y);
        ctx.rotate((player.rotation * Math.PI) / 180);

        const scale = Math.max(0.5, playerPos.w * 2);
        ctx.scale(scale, scale);

        // Shadow
        ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
        ctx.ellipse(0, 60, 35, 12, 0, 0, Math.PI * 2);
        ctx.fill();

        // Bike wheels
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.arc(-20, 25, 18, 0, Math.PI * 2);
        ctx.arc(20, 25, 18, 0, Math.PI * 2);
        ctx.stroke();

        // Wheel spokes (animated)
        ctx.strokeStyle = "#666";
        ctx.lineWidth = 2;
        const spokeRotation = Date.now() * 0.02 * player.velocityZ;
        for (let wheel of [-20, 20]) {
          for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2 + spokeRotation;
            ctx.beginPath();
            ctx.moveTo(wheel, 25);
            ctx.lineTo(wheel + Math.cos(angle) * 12, 25 + Math.sin(angle) * 12);
            ctx.stroke();
          }
        }

        // Bike frame
        ctx.strokeStyle = "#FF4444";
        ctx.lineWidth = 6;
        ctx.beginPath();
        // Main triangle
        ctx.moveTo(-15, 15);
        ctx.lineTo(0, -15);
        ctx.lineTo(15, 15);
        ctx.lineTo(-15, 15);
        // Seat post
        ctx.moveTo(0, -15);
        ctx.lineTo(-5, -25);
        // Fork
        ctx.moveTo(15, 15);
        ctx.lineTo(20, 5);
        ctx.stroke();

        // Handlebars
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(15, -5);
        ctx.lineTo(25, -10);
        ctx.moveTo(15, -5);
        ctx.lineTo(5, -10);
        ctx.stroke();

        // Rider body
        ctx.fillStyle = "#4169E1"; // Blue jersey
        ctx.fillRect(-8, -35, 16, 20);

        // Rider head
        ctx.fillStyle = "#FFDBAC"; // Skin tone
        ctx.beginPath();
        ctx.arc(0, -45, 8, 0, Math.PI * 2);
        ctx.fill();

        // Helmet
        ctx.fillStyle = "#FF6B6B";
        ctx.beginPath();
        ctx.arc(0, -47, 10, Math.PI, Math.PI * 2);
        ctx.fill();

        // Arms
        ctx.strokeStyle = "#FFDBAC";
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(-8, -25);
        ctx.lineTo(-15, -15);
        ctx.lineTo(-10, -5);
        ctx.moveTo(8, -25);
        ctx.lineTo(15, -15);
        ctx.lineTo(10, -5);
        ctx.stroke();

        // Legs
        ctx.beginPath();
        ctx.moveTo(-5, -15);
        ctx.lineTo(-12, 10);
        ctx.lineTo(-18, 20);
        ctx.moveTo(5, -15);
        ctx.lineTo(12, 10);
        ctx.lineTo(18, 20);
        ctx.stroke();

        // Pedals
        ctx.fillStyle = "#333";
        ctx.fillRect(-22, 18, 8, 4);
        ctx.fillRect(14, 18, 8, 4);

        ctx.restore();
      }

      // Game loop
      function gameLoop() {
        if (!game.running) return;

        updatePlayer();
        updateParticles();
        render();
        updateUI();

        requestAnimationFrame(gameLoop);
      }

      function updateUI() {
        const currentTime = Date.now();
        game.gameTime = Math.floor((currentTime - game.startTime) / 1000);

        document.getElementById("distance").textContent = game.distance;
        document.getElementById("score").textContent = game.score;
        document.getElementById("speed").textContent = Math.floor(
          player.velocityZ * 3.6
        );
        document.getElementById("health").textContent = Math.floor(
          player.health
        );
        document.getElementById("altitude").textContent = Math.floor(
          2500 - game.distance / 4
        );

        const minutes = Math.floor(game.gameTime / 60);
        const seconds = game.gameTime % 60;
        document.getElementById("gameTime").textContent = `${minutes}:${seconds
          .toString()
          .padStart(2, "0")}`;
      }

      function gameOver() {
        game.running = false;

        document.getElementById("finalDistance").textContent = game.distance;
        document.getElementById("finalScore").textContent = game.score;
        document.getElementById("maxSpeed").textContent = game.maxSpeed;

        const minutes = Math.floor(game.gameTime / 60);
        const seconds = game.gameTime % 60;
        document.getElementById("finalTime").textContent = `${minutes}:${seconds
          .toString()
          .padStart(2, "0")}`;

        document.getElementById("gameOverScreen").style.display = "block";
      }

      function restartGame() {
        // Reset game state
        game.running = true;
        game.score = 0;
        game.distance = 0;
        game.gameTime = 0;
        game.maxSpeed = 0;
        game.startTime = Date.now();
        game.cameraZ = 0;

        // Reset player
        player.x = 0;
        player.y = 0;
        player.z = 0;
        player.velocityX = 0;
        player.velocityY = 0;
        player.velocityZ = 12;
        player.jumpPower = 0;
        player.onGround = true;
        player.health = 100;
        player.rotation = 0;
        player.lean = 0;

        // Clear particles
        particles.length = 0;

        // Regenerate road
        initRoad();

        // Hide game over screen
        document.getElementById("gameOverScreen").style.display = "none";

        // Restart game loop
        gameLoop();
      }

      // Initialize game
      initRoad();
      gameLoop();

      // Pause/resume with P key
      document.addEventListener("keydown", (e) => {
        if (e.key.toLowerCase() === "p") {
          game.paused = !game.paused;
          if (!game.paused) {
            gameLoop();
          }
        }
      });

      // Prevent context menu on right click
      canvas.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });
    </script>
  </body>
</html>
