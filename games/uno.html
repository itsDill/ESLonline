<!DOCTYPE html>
<html lang="en">
  <head>
    <script
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2456627863532019"
      crossorigin="anonymous"
    ></script>
    <!-- Google tag (gtag.js) -->
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-9G9RD6BHLN"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());
      gtag("config", "G-9G9RD6BHLN");
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      English UNO Card Game - Master Vocabulary & Strategy | ESL Fun Online
    </title>
    <meta
      name="description"
      content="Play UNO with English word challenges! Master card strategy while building vocabulary. Fun educational game with speaking prompts, perfect for ESL learners of all levels."
    />
    <meta
      name="keywords"
      content="English UNO game, ESL card game, vocabulary building, English learning game, UNO word challenge, interactive learning, educational games"
    />
    <meta name="author" content="ESL Fun Online" />
    <meta name="robots" content="index, follow" />
    <meta name="language" content="English" />

    <!-- Open Graph Tags -->
    <meta
      property="og:title"
      content="English UNO Card Game - Master Vocabulary & Strategy | ESL Fun Online"
    />
    <meta
      property="og:description"
      content="Play UNO with English word challenges! Master card strategy while building vocabulary through fun gameplay."
    />
    <meta
      property="og:image"
      content="https://eslfunonline.com/images/image copy 12.png"
    />
    <meta property="og:url" content="https://eslfunonline.com/games/uno.html" />
    <meta property="og:type" content="game" />
    <meta property="og:locale" content="en_US" />

    <!-- Twitter Cards -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:title"
      content="English UNO Card Game - Vocabulary & Strategy"
    />
    <meta
      name="twitter:description"
      content="Play UNO with English word challenges! Perfect for ESL learners."
    />
    <meta
      name="twitter:image"
      content="https://eslfunonline.com/images/image copy 12.png"
    />

    <!-- Canonical URL -->
    <link rel="canonical" href="https://eslfunonline.com/games/uno.html" />

    <!-- Structured Data -->
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Game",
        "name": "English UNO Card Game",
        "description": "Play UNO with English word challenges! Master card strategy while building vocabulary through fun gameplay.",
        "url": "https://eslfunonline.com/games/uno.html",
        "image": "https://eslfunonline.com/images/image copy 12.png",
        "publisher": {
          "@type": "Organization",
          "name": "ESL Fun Online",
          "url": "https://eslfunonline.com"
        },
        "genre": ["Educational", "Card Game", "Vocabulary"],
        "audience": {
          "@type": "EducationalAudience",
          "educationalRole": "student",
          "audienceType": "ESL Learners"
        },
        "educationalUse": "Vocabulary Building",
        "interactivityType": "active",
        "learningResourceType": "game"
      }
    </script>

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Poppins:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../css/game-ads.css" />

    <style>
      :root {
        --primary-color: #46bbe5;
        --red-card: #ef4444;
        --blue-card: #3b82f6;
        --green-card: #10b981;
        --yellow-card: #f59e0b;
        --wild-card: #1f2937;
        --bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        --card-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        --card-hover-shadow: 0 12px 35px rgba(0, 0, 0, 0.25);
        --text-primary: #1f2937;
        --text-secondary: #6b7280;
        --bg-primary: #ffffff;
        --bg-secondary: #f9fafb;
        --success-color: #10b981;
        --warning-color: #f59e0b;
        --error-color: #ef4444;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", sans-serif;
        background: url("../images/image copy 11.png") center/cover no-repeat,
          var(--bg-gradient);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        color: var(--text-primary);
        overflow-x: hidden;
      }

      /* Header - Compact for better space usage */
      .game-header {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        padding: 0.75rem 0;
        box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
        position: sticky;
        top: 0;
        z-index: 1000;
      }

      .header-content {
        max-width: 1400px;
        margin: 0 auto;
        padding: 0 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .game-title {
        font-family: "Poppins", sans-serif;
        font-size: 1.5rem;
        font-weight: 700;
        background: linear-gradient(135deg, #ff6b6b, #4ecdc4, #45b7d1);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .game-controls {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .control-btn {
        padding: 0.4rem 0.8rem;
        border: none;
        border-radius: 8px;
        background: var(--primary-color);
        color: white;
        cursor: pointer;
        font-weight: 500;
        font-size: 0.85rem;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 0.4rem;
      }

      .control-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
      }

      .control-btn.secondary {
        background: transparent;
        color: var(--primary-color);
        border: 2px solid var(--primary-color);
      }

      /* Game Container - Better space utilization */
      .game-container {
        flex: 1;
        max-width: 1400px;
        margin: 0 auto;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        height: calc(100vh - 80px);
      }

      /* Game Status - More compact */
      .game-status {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: var(--card-shadow);
      }

      .status-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-weight: 600;
        font-size: 0.9rem;
      }

      .status-icon {
        width: 35px;
        height: 35px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1rem;
        color: white;
      }

      .player-icon {
        background: var(--success-color);
      }

      .computer-icon {
        background: var(--error-color);
      }

      .turn-indicator {
        background: var(--warning-color);
        padding: 0.4rem 0.8rem;
        border-radius: 20px;
        color: white;
        font-weight: 600;
        font-size: 0.9rem;
        animation: pulse 2s infinite;
      }

      .thinking-indicator {
        background: var(--primary-color);
        animation: thinking 1s infinite ease-in-out;
      }

      @keyframes thinking {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.6;
        }
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      /* Game Board - Optimized layout */
      .game-board {
        flex: 1;
        display: grid;
        grid-template-areas:
          "computer computer computer"
          "deck current actions"
          "player player player";
        grid-template-columns: 1fr 2fr 1fr;
        grid-template-rows: 1fr auto 1fr;
        gap: 1rem;
        align-items: center;
        min-height: 0;
      }

      .computer-hand {
        grid-area: computer;
        display: flex;
        justify-content: center;
        align-items: flex-end;
        gap: -15px;
        padding: 0.5rem;
      }

      .deck-area {
        grid-area: deck;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
      }

      .center-area {
        grid-area: current;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
      }

      .action-area {
        grid-area: actions;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
      }

      .player-hand {
        grid-area: player;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        gap: 0.3rem;
        flex-wrap: wrap;
        padding: 0.5rem;
        max-height: 200px;
        overflow-y: auto;
      }

      /* Card Styles - Improved for better readability */
      .card {
        width: 90px;
        height: 135px;
        border-radius: 12px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: var(--card-shadow);
        position: relative;
        font-weight: 800;
        font-size: 1rem;
        border: 3px solid rgba(255, 255, 255, 0.4);
        user-select: none;
        color: white;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }

      /* Corner numbers for better readability */
      .card::after {
        content: attr(data-value);
        position: absolute;
        top: 8px;
        left: 8px;
        font-size: 0.8rem;
        font-weight: 900;
        opacity: 0.9;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      }

      .card::before {
        content: attr(data-value);
        position: absolute;
        bottom: 8px;
        right: 8px;
        font-size: 0.8rem;
        font-weight: 900;
        opacity: 0.9;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        transform: rotate(180deg);
      }

      .card:hover {
        transform: translateY(-8px) scale(1.05);
        box-shadow: var(--card-hover-shadow);
        z-index: 10;
      }

      .card.playable {
        animation: glow 2s infinite alternate;
        border-color: #ffd700;
        cursor: pointer;
      }

      @keyframes glow {
        from {
          box-shadow: var(--card-shadow);
        }
        to {
          box-shadow: 0 0 20px #ffd700, var(--card-shadow);
        }
      }

      .card.red {
        background: linear-gradient(135deg, #e53e3e, #ff6b6b);
        border-color: #c53030;
        box-shadow: 0 8px 25px rgba(229, 62, 62, 0.3);
      }
      .card.blue {
        background: linear-gradient(135deg, #3182ce, #4299e1);
        border-color: #2b77cb;
        box-shadow: 0 8px 25px rgba(49, 130, 206, 0.3);
      }
      .card.green {
        background: linear-gradient(135deg, #38a169, #48bb78);
        border-color: #2f855a;
        box-shadow: 0 8px 25px rgba(56, 161, 105, 0.3);
      }
      .card.yellow {
        background: linear-gradient(135deg, #d69e2e, #ecc94b);
        border-color: #b7791f;
        color: #1a202c;
        text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        box-shadow: 0 8px 25px rgba(214, 158, 46, 0.3);
      }
      .card.wild {
        background: linear-gradient(135deg, #2d3748, #4a5568);
        border: 3px solid #a0aec0;
        color: white;
        position: relative;
        overflow: hidden;
        box-shadow: 0 8px 25px rgba(45, 55, 72, 0.4);
      }

      .card.wild::after,
      .card.wild::before {
        z-index: 3;
        background: rgba(0, 0, 0, 0.8);
        padding: 2px 4px;
        border-radius: 3px;
      }

      .card.wild .card-content {
        z-index: 2 !important;
      }

      .card.wild .wild-bg {
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: conic-gradient(
          from 0deg,
          #e53e3e 0deg 90deg,
          #3182ce 90deg 180deg,
          #38a169 180deg 270deg,
          #d69e2e 270deg 360deg
        );
        animation: wildRotate 4s linear infinite;
        z-index: 1;
      }

      @keyframes wildRotate {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .card-back {
        background: linear-gradient(135deg, #1e3c72, #2a5298);
        color: white;
        cursor: default;
      }

      .card-back:hover {
        transform: none;
        box-shadow: var(--card-shadow);
      }

      .card-number {
        font-size: 1.8rem;
        font-weight: 900;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        margin-bottom: 0.2rem;
      }

      .card-icon {
        font-size: 1.2rem;
        margin-bottom: 0.2rem;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }

      .card-vocabulary {
        font-size: 0.75rem;
        font-weight: 700;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        margin-top: 0.2rem;
      }

      /* Deck and Draw Pile */
      .draw-deck {
        position: relative;
        cursor: pointer;
      }

      .draw-deck .card {
        position: absolute;
      }

      .draw-deck .card:nth-child(1) {
        transform: rotate(-2deg) translate(2px, 2px);
      }
      .draw-deck .card:nth-child(2) {
        transform: rotate(1deg) translate(-1px, 1px);
      }
      .draw-deck .card:nth-child(3) {
        transform: rotate(-1deg);
      }

      .current-card {
        position: relative;
        animation: slideIn 0.5s ease-out;
      }

      @keyframes slideIn {
        from {
          transform: scale(0) rotate(180deg);
          opacity: 0;
        }
        to {
          transform: scale(1) rotate(0deg);
          opacity: 1;
        }
      }

      /* Computer Cards with thinking animation */
      .computer-hand .card {
        margin-left: -12px;
        transform: rotate(var(--rotation, 0deg));
      }

      .computer-hand .card:nth-child(odd) {
        --rotation: -3deg;
      }

      .computer-hand .card:nth-child(even) {
        --rotation: 3deg;
      }

      .computer-thinking .card {
        animation: cardThinking 0.8s infinite ease-in-out;
      }

      @keyframes cardThinking {
        0%,
        100% {
          transform: rotate(var(--rotation, 0deg)) translateY(0);
        }
        50% {
          transform: rotate(var(--rotation, 0deg)) translateY(-5px);
        }
      }

      /* Action Buttons */
      .action-buttons {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .action-btn {
        padding: 0.6rem 1rem;
        border: none;
        border-radius: 10px;
        font-weight: 600;
        font-size: 0.8rem;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.4rem;
        min-width: 120px;
      }

      .draw-btn {
        background: var(--primary-color);
        color: white;
      }

      .uno-btn {
        background: var(--error-color);
        color: white;
        animation: shake 0.5s;
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-3px);
        }
        75% {
          transform: translateX(3px);
        }
      }

      .action-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      .action-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      /* Color Picker Modal */
      .color-picker {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 2000;
      }

      .color-picker.show {
        display: flex;
      }

      .color-options {
        background: white;
        padding: 1.5rem;
        border-radius: 20px;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 1rem;
        box-shadow: var(--card-hover-shadow);
      }

      .color-option {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        border: none;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        color: white;
        font-weight: 700;
      }

      .color-option:hover {
        transform: scale(1.1);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      }

      .color-option.red {
        background: var(--red-card);
      }
      .color-option.blue {
        background: var(--blue-card);
      }
      .color-option.green {
        background: var(--green-card);
      }
      .color-option.yellow {
        background: var(--yellow-card);
      }

      /* Game Messages */
      .game-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 2rem;
        border-radius: 20px;
        box-shadow: var(--card-hover-shadow);
        text-align: center;
        z-index: 2000;
        display: none;
        max-width: 400px;
      }

      .game-message.show {
        display: block;
        animation: messageSlide 0.5s ease-out;
      }

      @keyframes messageSlide {
        from {
          transform: translate(-50%, -50%) scale(0);
          opacity: 0;
        }
        to {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
      }

      .message-title {
        font-size: 1.4rem;
        font-weight: 700;
        margin-bottom: 1rem;
        color: var(--primary-color);
      }

      .message-text {
        color: var(--text-secondary);
        margin-bottom: 1.5rem;
        line-height: 1.5;
      }

      .message-btn {
        padding: 0.75rem 1.5rem;
        background: var(--primary-color);
        color: white;
        border: none;
        border-radius: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .message-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
      }

      /* Score and Statistics */
      .game-stats {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 10px;
        padding: 0.8rem;
        text-align: center;
        font-size: 0.8rem;
        font-weight: 600;
        color: var(--text-secondary);
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        .game-container {
          padding: 0.5rem;
          height: calc(100vh - 70px);
        }

        .game-board {
          grid-template-areas:
            "computer"
            "deck"
            "current"
            "actions"
            "player";
          grid-template-columns: 1fr;
          grid-template-rows: auto auto auto auto 1fr;
          gap: 0.5rem;
        }

        .card {
          width: 70px;
          height: 105px;
          font-size: 0.8rem;
        }

        .card-number {
          font-size: 1.4rem;
        }

        .card-icon {
          font-size: 1rem;
        }

        .card-vocabulary {
          font-size: 0.65rem;
        }
        .game-status {
          flex-direction: column;
          gap: 0.5rem;
          text-align: center;
          padding: 0.8rem;
        }

        .header-content {
          padding: 0 0.5rem;
        }

        .game-title {
          font-size: 1.2rem;
        }

        .game-controls {
          gap: 0.3rem;
        }

        .control-btn {
          padding: 0.3rem 0.6rem;
          font-size: 0.75rem;
        }

        .color-options {
          grid-template-columns: repeat(4, 1fr);
          padding: 1rem;
        }

        .color-option {
          width: 50px;
          height: 50px;
          font-size: 1rem;
        }

        .player-hand {
          max-height: 150px;
          gap: 0.2rem;
        }
      }

      /* Loading Animation */
      .loading {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 1s ease-in-out infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Sound Toggle */
      .sound-toggle {
        position: fixed;
        top: 100px;
        right: 20px;
        background: rgba(255, 255, 255, 0.9);
        border: none;
        border-radius: 50%;
        width: 45px;
        height: 45px;
        cursor: pointer;
        font-size: 1.2rem;
        color: var(--primary-color);
        box-shadow: var(--card-shadow);
        transition: all 0.3s ease;
      }

      .sound-toggle:hover {
        transform: scale(1.1);
      }

      /* Hint System */
      .hint-overlay {
        position: absolute;
        top: -30px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--primary-color);
        color: white;
        padding: 0.3rem 0.6rem;
        border-radius: 15px;
        font-size: 0.7rem;
        white-space: nowrap;
        z-index: 100;
        opacity: 0;
        animation: hintFade 3s ease-in-out;
      }

      @keyframes hintFade {
        0%,
        100% {
          opacity: 0;
          transform: translateX(-50%) translateY(5px);
        }
        20%,
        80% {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }

      /* Combo indicator */
      .combo-indicator {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(45deg, #ff6b6b, #ffd93d);
        color: white;
        padding: 1rem 2rem;
        border-radius: 20px;
        font-size: 1.5rem;
        font-weight: bold;
        z-index: 1500;
        animation: comboShow 2s ease-out forwards;
        pointer-events: none;
      }

      @keyframes comboShow {
        0% {
          opacity: 0;
          transform: translate(-50%, -50%) scale(0) rotate(180deg);
        }
        50% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1.2) rotate(0deg);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -50%) scale(1) rotate(0deg);
        }
      }

      /* Enhanced card hover effects */
      .card.enhanced-hover {
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      }

      .card.enhanced-hover:hover {
        transform: translateY(-12px) scale(1.05) rotateX(10deg);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      }

      /* Particle effects */
      .particle {
        position: absolute;
        pointer-events: none;
        border-radius: 50%;
        animation: particleFloat 1s ease-out forwards;
      }

      @keyframes particleFloat {
        0% {
          opacity: 1;
          transform: scale(1) rotate(0deg);
        }
        100% {
          opacity: 0;
          transform: scale(0) rotate(360deg) translateY(-50px);
        }
      }

      /* Achievement notification */
      .achievement-notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #ffd700, #ffed4e);
        color: #1f2937;
        padding: 1rem;
        border-radius: 15px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        z-index: 2000;
        animation: achievementSlide 4s ease-out forwards;
        max-width: 300px;
      }

      @keyframes achievementSlide {
        0% {
          opacity: 0;
          transform: translateX(100%);
        }
        10%,
        90% {
          opacity: 1;
          transform: translateX(0);
        }
        100% {
          opacity: 0;
          transform: translateX(100%);
        }
      }

      /* Power-up effects */
      .power-up-glow {
        animation: powerUpGlow 2s infinite alternate;
        border: 2px solid gold !important;
      }

      @keyframes powerUpGlow {
        0% {
          box-shadow: 0 0 5px gold;
        }
        100% {
          box-shadow: 0 0 20px gold, 0 0 30px gold;
        }
      }

      /* Challenge progress animations */
      .challenge-complete {
        animation: challengePulse 1s ease-out;
      }

      @keyframes challengePulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      /* Disabled button styles */
      .message-btn:disabled {
        background: #6b7280 !important;
        cursor: not-allowed;
        opacity: 0.6;
      }

      /* Quiz feedback styles */
      .quiz-correct {
        background: var(--success-color) !important;
        animation: correctAnswer 0.5s ease-out;
      }

      .quiz-incorrect {
        background: var(--error-color) !important;
        animation: incorrectAnswer 0.5s ease-out;
      }

      @keyframes correctAnswer {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }

      @keyframes incorrectAnswer {
        0% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-5px);
        }
        75% {
          transform: translateX(5px);
        }
        100% {
          transform: translateX(0);
        }
      }
    </style>
    <link rel="canonical" href="https://eslfunonline.com/games/uno.html" />
    \n
  </head>
  <body>
    <header class="game-header">
      <div class="header-content">
        <h1 class="game-title">🎮 English UNO</h1>
        <div class="game-controls">
          <button class="control-btn" onclick="newGame()">
            <i class="fas fa-plus"></i>
            New Game
          </button>
          <button class="control-btn secondary" onclick="showSettings()">
            <i class="fas fa-cog"></i>
            Settings
          </button>
          <button class="control-btn secondary" onclick="showRules()">
            <i class="fas fa-question-circle"></i>
            Rules
          </button>
          <button class="control-btn secondary" onclick="showStats()">
            <i class="fas fa-chart-bar"></i>
            Stats
          </button>
          <button class="control-btn secondary" onclick="showAchievements()">
            <i class="fas fa-trophy"></i>
            Achievements
          </button>
          <button class="control-btn secondary" onclick="showVocabularyQuiz()">
            <i class="fas fa-book"></i>
            Vocab Quiz
          </button>
          <button class="control-btn secondary" onclick="showWordProgress()">
            <i class="fas fa-chart-line"></i>
            Progress
          </button>
          <button class="control-btn secondary" onclick="showDailyChallenges()">
            <i class="fas fa-calendar-check"></i>
            Challenges
          </button>
          <button class="control-btn secondary" onclick="showPowerUps()">
            <i class="fas fa-magic"></i>
            Power-Ups
          </button>
        </div>
      </div>
    </header>

    <button class="sound-toggle" id="soundToggle" onclick="toggleSound()">
      <i class="fas fa-volume-up"></i>
    </button>

    <div class="game-container">
      <!-- Game Status -->
      <div class="game-status">
        <div class="status-item">
          <div class="status-icon player-icon">
            <i class="fas fa-user"></i>
          </div>
          <div>
            <div>You</div>
            <div id="playerCardCount">7 cards</div>
            <div
              id="playerCombo"
              style="font-size: 0.7rem; color: var(--success-color)"
            >
              Combo: 0
            </div>
          </div>
        </div>

        <div class="turn-indicator" id="turnIndicator">Your Turn</div>

        <div class="status-item">
          <div class="status-icon computer-icon">
            <i class="fas fa-robot"></i>
          </div>
          <div>
            <div>Computer</div>
            <div id="computerCardCount">7 cards</div>
            <div
              id="difficultyDisplay"
              style="font-size: 0.7rem; color: var(--warning-color)"
            >
              Beginner
            </div>
          </div>
        </div>
      </div>

      <!-- Game Board -->
      <div class="game-board">
        <!-- Computer Hand -->
        <div class="computer-hand" id="computerHand">
          <!-- Computer cards will be generated here -->
        </div>

        <!-- Draw Deck -->
        <div class="deck-area">
          <div class="draw-deck" onclick="drawCard()">
            <div class="card card-back">
              <div class="card-number">UNO</div>
              <div class="card-icon">
                <i class="fas fa-layer-group"></i>
              </div>
            </div>
            <div class="card card-back"></div>
            <div class="card card-back"></div>
          </div>
          <div class="game-stats">
            <div>Draw Pile</div>
            <div id="deckCount">Cards: 94</div>
          </div>
        </div>

        <!-- Center Area -->
        <div class="center-area">
          <div class="card current-card" id="currentCard">
            <!-- Current card will be displayed here -->
          </div>
          <div class="game-stats">
            <div>Current Card</div>
            <div id="currentColor">Color: Red</div>
          </div>
        </div>

        <!-- Action Area -->
        <div class="action-area">
          <div class="action-buttons">
            <button
              class="action-btn draw-btn"
              id="drawBtn"
              onclick="drawCard()"
            >
              <i class="fas fa-plus"></i>
              Draw
            </button>
            <button
              class="action-btn uno-btn"
              id="unoBtn"
              onclick="callUno()"
              style="display: none"
            >
              <i class="fas fa-exclamation"></i>
              UNO!
            </button>
          </div>
          <div class="game-stats">
            <div id="gameTimer">Time: 0:00</div>
            <div id="moveCount">Moves: 0</div>
          </div>
        </div>

        <!-- Player Hand -->
        <div class="player-hand" id="playerHand">
          <!-- Player cards will be generated here -->
        </div>
      </div>
    </div>

    <!-- Color Picker Modal -->
    <div class="color-picker" id="colorPicker">
      <div class="color-options">
        <button class="color-option red" onclick="selectColor('red')">R</button>
        <button class="color-option blue" onclick="selectColor('blue')">
          B
        </button>
        <button class="color-option green" onclick="selectColor('green')">
          G
        </button>
        <button class="color-option yellow" onclick="selectColor('yellow')">
          Y
        </button>
      </div>
    </div>

    <!-- Game Message Modal -->
    <div class="game-message" id="gameMessage">
      <div class="message-title" id="messageTitle">Game Over!</div>
      <div class="message-text" id="messageText">Congratulations! You won!</div>
      <button class="message-btn" onclick="closeMessage()">Continue</button>
    </div>

    <!-- Settings Modal -->
    <div class="game-message" id="settingsModal" style="max-width: 500px">
      <div class="message-title">Game Settings</div>
      <div style="text-align: left; margin: 1rem 0">
        <div style="margin-bottom: 1rem">
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600"
            >Difficulty Level:</label
          >
          <select
            id="difficultySelect"
            style="
              width: 100%;
              padding: 0.5rem;
              border-radius: 8px;
              border: 2px solid #e5e7eb;
            "
          >
            <option value="beginner">Beginner - Easy words</option>
            <option value="intermediate">Intermediate - Medium words</option>
            <option value="advanced">Advanced - Challenging words</option>
          </select>
        </div>
        <div style="margin-bottom: 1rem">
          <label style="display: flex; align-items: center; gap: 0.5rem">
            <input type="checkbox" id="soundToggleCheck" checked />
            <span>Sound Effects</span>
          </label>
        </div>
        <div style="margin-bottom: 1rem">
          <label style="display: flex; align-items: center; gap: 0.5rem">
            <input type="checkbox" id="animationsToggleCheck" checked />
            <span>Animations</span>
          </label>
        </div>
        <div style="margin-bottom: 1rem">
          <label style="display: flex; align-items: center; gap: 0.5rem">
            <input type="checkbox" id="hintsToggleCheck" checked />
            <span>Show Hints</span>
          </label>
        </div>
      </div>
      <div style="display: flex; gap: 0.5rem">
        <button class="message-btn" onclick="saveSettings()">Save</button>
        <button
          class="message-btn"
          style="background: #6b7280"
          onclick="closeSettings()"
        >
          Cancel
        </button>
      </div>
    </div>

    <!-- Achievements Modal -->
    <div class="game-message" id="achievementsModal" style="max-width: 600px">
      <div class="message-title">🏆 Achievements</div>
      <div
        id="achievementsList"
        style="
          text-align: left;
          margin: 1rem 0;
          max-height: 300px;
          overflow-y: auto;
        "
      >
        <!-- Achievements will be populated here -->
      </div>
      <button class="message-btn" onclick="closeAchievements()">Close</button>
    </div>

    <!-- Word Learning Modal -->
    <div class="game-message" id="wordModal" style="max-width: 400px">
      <div class="message-title">📚 Learn This Word!</div>
      <div id="wordContent" style="text-align: center; margin: 1rem 0">
        <!-- Word content will be populated here -->
      </div>
      <div style="display: flex; gap: 0.5rem">
        <button class="message-btn" onclick="markWordLearned()">
          I Know This!
        </button>
        <button
          class="message-btn"
          style="background: #6b7280"
          onclick="closeWordModal()"
        >
          Skip
        </button>
      </div>
    </div>

    <!-- Vocabulary Quiz Modal -->
    <div class="game-message" id="vocabularyQuizModal" style="max-width: 500px">
      <div class="message-title">📝 Vocabulary Quiz</div>
      <div
        id="quizContent"
        style="text-align: center; margin: 1rem 0; min-height: 200px"
      >
        <!-- Quiz content will be populated here -->
      </div>
      <div style="display: flex; gap: 0.5rem; justify-content: center">
        <button
          class="message-btn"
          id="quizOption1"
          onclick="selectQuizAnswer(0)"
        ></button>
        <button
          class="message-btn"
          id="quizOption2"
          onclick="selectQuizAnswer(1)"
        ></button>
        <button
          class="message-btn"
          id="quizOption3"
          onclick="selectQuizAnswer(2)"
        ></button>
      </div>
      <div style="margin-top: 1rem; text-align: center">
        <span id="quizScore">Score: 0/0</span>
        <button
          class="message-btn"
          style="background: #6b7280; margin-left: 1rem"
          onclick="closeVocabularyQuiz()"
        >
          Close Quiz
        </button>
      </div>
    </div>

    <!-- Word Progress Modal -->
    <div class="game-message" id="wordProgressModal" style="max-width: 600px">
      <div class="message-title">📈 Your Learning Progress</div>
      <div
        id="progressContent"
        style="
          text-align: left;
          margin: 1rem 0;
          max-height: 400px;
          overflow-y: auto;
        "
      >
        <!-- Progress content will be populated here -->
      </div>
      <button class="message-btn" onclick="closeWordProgress()">Close</button>
    </div>

    <!-- Daily Challenges Modal -->
    <div
      class="game-message"
      id="dailyChallengesModal"
      style="max-width: 600px"
    >
      <div class="message-title">🎯 Daily Challenges</div>
      <div
        id="challengesContent"
        style="
          text-align: left;
          margin: 1rem 0;
          max-height: 400px;
          overflow-y: auto;
        "
      >
        <!-- Challenges content will be populated here -->
      </div>
      <button class="message-btn" onclick="closeDailyChallenges()">
        Close
      </button>
    </div>

    <!-- Power-Ups Modal -->
    <div class="game-message" id="powerUpsModal" style="max-width: 600px">
      <div class="message-title">⚡ Power-Ups</div>
      <div
        id="powerUpsContent"
        style="
          text-align: left;
          margin: 1rem 0;
          max-height: 400px;
          overflow-y: auto;
        "
      >
        <!-- Power-ups content will be populated here -->
      </div>
      <div style="display: flex; gap: 0.5rem; justify-content: center">
        <button class="message-btn" onclick="closePowerUps()">Close</button>
      </div>
    </div>

    <script>
      // Game State
      let gameState = {
        playerHand: [],
        computerHand: [],
        deck: [],
        discardPile: [],
        currentCard: null,
        currentColor: null,
        playerTurn: true,
        gameOver: false,
        playerCalledUno: false,
        computerCalledUno: false,
        computerThinking: false,
        gameStartTime: null,
        moveCount: 0,
        soundEnabled: true,
        animationsEnabled: true,
        showHints: true,
        learnedWords: new Set(
          JSON.parse(localStorage.getItem("learnedWords") || "[]")
        ),
        cardsPlayed: parseInt(localStorage.getItem("cardsPlayed")) || 0,
        combo: 0,
        maxCombo: parseInt(localStorage.getItem("maxCombo")) || 0,
        quiz: {
          score: 0,
          totalQuestions: 0,
          currentQuestion: null,
          options: [],
          correctAnswer: 0,
        },
        wordProgress: JSON.parse(localStorage.getItem("wordProgress") || "{}"),
        streak: parseInt(localStorage.getItem("learningStreak")) || 0,
        dailyGoal: parseInt(localStorage.getItem("dailyGoal")) || 5,
        wordsLearnedToday: 0,
        powerUps: {
          hints: parseInt(localStorage.getItem("powerUpHints")) || 3,
          skipTurn: parseInt(localStorage.getItem("powerUpSkipTurn")) || 1,
          peekCards: parseInt(localStorage.getItem("powerUpPeekCards")) || 2,
          extraTime: parseInt(localStorage.getItem("powerUpExtraTime")) || 1,
        },
        dailyChallenges: {
          current: JSON.parse(localStorage.getItem("dailyChallenges") || "[]"),
          completed: JSON.parse(
            localStorage.getItem("completedChallenges") || "[]"
          ),
          lastReset:
            localStorage.getItem("challengesLastReset") ||
            new Date().toDateString(),
        },
        stats: {
          gamesPlayed: parseInt(localStorage.getItem("gamesPlayed")) || 0,
          gamesWon: parseInt(localStorage.getItem("gamesWon")) || 0,
          totalTime: parseInt(localStorage.getItem("totalTime")) || 0,
          fastestWin: parseInt(localStorage.getItem("fastestWin")) || Infinity,
        },
      };

      // Enhanced Card definitions - Clean color-based design
      const colors = ["red", "blue", "green", "yellow"];
      const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
      const actions = ["skip", "reverse", "draw2"];

      // Enhanced vocabulary words with difficulty levels
      const vocabularyWords = {
        red: [
          {
            word: "apple",
            pronunciation: "/ˈæpəl/",
            level: "beginner",
            definition: "a round fruit",
          },
          {
            word: "fire",
            pronunciation: "/faɪər/",
            level: "beginner",
            definition: "hot flames",
          },
          {
            word: "rose",
            pronunciation: "/roʊz/",
            level: "beginner",
            definition: "a beautiful flower",
          },
          {
            word: "cherry",
            pronunciation: "/ˈtʃeri/",
            level: "intermediate",
            definition: "small red fruit",
          },
          {
            word: "tomato",
            pronunciation: "/təˈmeɪtoʊ/",
            level: "intermediate",
            definition: "red vegetable for salads",
          },
          {
            word: "crimson",
            pronunciation: "/ˈkrɪmzən/",
            level: "advanced",
            definition: "deep red color",
          },
          {
            word: "scarlet",
            pronunciation: "/ˈskɑrlət/",
            level: "advanced",
            definition: "bright red color",
          },
        ],
        blue: [
          {
            word: "sky",
            pronunciation: "/skaɪ/",
            level: "beginner",
            definition: "what we see above us",
          },
          {
            word: "ocean",
            pronunciation: "/ˈoʊʃən/",
            level: "beginner",
            definition: "large body of water",
          },
          {
            word: "ice",
            pronunciation: "/aɪs/",
            level: "beginner",
            definition: "frozen water",
          },
          {
            word: "whale",
            pronunciation: "/weɪl/",
            level: "intermediate",
            definition: "large sea mammal",
          },
          {
            word: "blueberry",
            pronunciation: "/ˈbluˌberi/",
            level: "intermediate",
            definition: "small blue fruit",
          },
          {
            word: "sapphire",
            pronunciation: "/ˈsæfaɪər/",
            level: "advanced",
            definition: "blue precious stone",
          },
          {
            word: "azure",
            pronunciation: "/ˈæʒər/",
            level: "advanced",
            definition: "bright blue color",
          },
        ],
        green: [
          {
            word: "grass",
            pronunciation: "/ɡræs/",
            level: "beginner",
            definition: "plants in the yard",
          },
          {
            word: "tree",
            pronunciation: "/tri/",
            level: "beginner",
            definition: "tall plant with leaves",
          },
          {
            word: "leaf",
            pronunciation: "/lif/",
            level: "beginner",
            definition: "part of a plant",
          },
          {
            word: "frog",
            pronunciation: "/frɔɡ/",
            level: "intermediate",
            definition: "jumping amphibian",
          },
          {
            word: "broccoli",
            pronunciation: "/ˈbrɑkəli/",
            level: "intermediate",
            definition: "green vegetable",
          },
          {
            word: "emerald",
            pronunciation: "/ˈemərəld/",
            level: "advanced",
            definition: "green precious stone",
          },
          {
            word: "verdant",
            pronunciation: "/ˈvɜrdənt/",
            level: "advanced",
            definition: "green and lush",
          },
        ],
        yellow: [
          {
            word: "sun",
            pronunciation: "/sʌn/",
            level: "beginner",
            definition: "star that gives us light",
          },
          {
            word: "banana",
            pronunciation: "/bəˈnænə/",
            level: "beginner",
            definition: "yellow curved fruit",
          },
          {
            word: "gold",
            pronunciation: "/ɡoʊld/",
            level: "beginner",
            definition: "valuable metal",
          },
          {
            word: "star",
            pronunciation: "/stɑr/",
            level: "intermediate",
            definition: "bright light in the sky",
          },
          {
            word: "lemon",
            pronunciation: "/ˈlemən/",
            level: "intermediate",
            definition: "sour yellow fruit",
          },
          {
            word: "amber",
            pronunciation: "/ˈæmbər/",
            level: "advanced",
            definition: "yellowish fossil resin",
          },
          {
            word: "canary",
            pronunciation: "/kəˈneri/",
            level: "advanced",
            definition: "small yellow bird",
          },
        ],
      };

      // Difficulty levels
      let difficultyLevel = localStorage.getItem("unodifficulty") || "beginner";

      // Achievement system
      const achievements = {
        firstWin: {
          name: "First Victory",
          description: "Win your first game",
          unlocked: false,
        },
        fastWin: {
          name: "Speed Demon",
          description: "Win in under 2 minutes",
          unlocked: false,
        },
        unoMaster: {
          name: "UNO Master",
          description: "Win 10 games",
          unlocked: false,
        },
        vocabularyExpert: {
          name: "Word Wizard",
          description: "Learn 50 new words",
          unlocked: false,
        },
        cardShark: {
          name: "Card Shark",
          description: "Play 100 cards",
          unlocked: false,
        },
      };

      // Load achievements
      Object.keys(achievements).forEach((key) => {
        achievements[key].unlocked =
          localStorage.getItem(`achievement_${key}`) === "true";
      });

      // Initialize game
      function initGame() {
        gameState.gameStartTime = Date.now();
        gameState.moveCount = 0;
        createDeck();
        shuffleDeck();
        dealCards();
        setStartingCard();
        updateDisplay();
        checkForPlayableCards();
        startGameTimer();
      }

      // Create a standard UNO deck
      function createDeck() {
        gameState.deck = [];

        // Number cards (0-9) for each color
        colors.forEach((color) => {
          numbers.forEach((number) => {
            gameState.deck.push({ color, value: number, type: "number" });
            if (number !== 0) {
              gameState.deck.push({ color, value: number, type: "number" });
            }
          });

          // Action cards (2 of each per color)
          actions.forEach((action) => {
            gameState.deck.push({ color, value: action, type: "action" });
            gameState.deck.push({ color, value: action, type: "action" });
          });
        });

        // Wild cards (4 of each)
        for (let i = 0; i < 4; i++) {
          gameState.deck.push({ color: "wild", value: "wild", type: "wild" });
          gameState.deck.push({ color: "wild", value: "draw4", type: "wild" });
        }
      }

      // Shuffle deck using Fisher-Yates algorithm
      function shuffleDeck() {
        for (let i = gameState.deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [gameState.deck[i], gameState.deck[j]] = [
            gameState.deck[j],
            gameState.deck[i],
          ];
        }
      }

      // Deal initial cards
      function dealCards() {
        gameState.playerHand = [];
        gameState.computerHand = [];

        // Deal 7 cards to each player
        for (let i = 0; i < 7; i++) {
          gameState.playerHand.push(gameState.deck.pop());
          gameState.computerHand.push(gameState.deck.pop());
        }
      }

      // Set the starting card
      function setStartingCard() {
        let startCard;
        do {
          startCard = gameState.deck.pop();
        } while (startCard.type === "wild");

        gameState.currentCard = startCard;
        gameState.currentColor = startCard.color;
        gameState.discardPile = [startCard];
      }

      // Update the display
      function updateDisplay() {
        updatePlayerHand();
        updateComputerHand();
        updateCurrentCard();
        updateGameStatus();
        updateUnoButton();
      }

      // Update player hand display
      function updatePlayerHand() {
        const playerHand = document.getElementById("playerHand");
        playerHand.innerHTML = "";

        gameState.playerHand.forEach((card, index) => {
          const cardElement = createCardElement(card, index, true);
          playerHand.appendChild(cardElement);
        });
      }

      // Update computer hand display
      function updateComputerHand() {
        const computerHand = document.getElementById("computerHand");
        computerHand.innerHTML = "";

        // Add thinking class if computer is thinking
        if (gameState.computerThinking) {
          computerHand.classList.add("computer-thinking");
        } else {
          computerHand.classList.remove("computer-thinking");
        }

        gameState.computerHand.forEach((card, index) => {
          const cardElement = createCardElement(null, index, false);
          computerHand.appendChild(cardElement);
        });
      }

      // Create card element
      function createCardElement(card, index, isPlayer) {
        const cardDiv = document.createElement("div");
        cardDiv.className = "card";

        // Add enhanced hover effects if animations are enabled
        if (gameState.animationsEnabled) {
          cardDiv.classList.add("enhanced-hover");
        }

        if (!isPlayer) {
          // Computer card (face down)
          cardDiv.classList.add("card-back");
          cardDiv.innerHTML = `
                    <div class="card-number">UNO</div>
                    <div class="card-icon"><i class="fas fa-question"></i></div>
                `;
        } else {
          // Player card (face up)
          cardDiv.classList.add(card.color);

          // Add data attribute for corner display
          if (card.type === "number") {
            cardDiv.setAttribute("data-value", card.value);
          } else if (card.type === "action") {
            const actionSymbols = { skip: "⊘", reverse: "↻", draw2: "+2" };
            cardDiv.setAttribute(
              "data-value",
              actionSymbols[card.value] || card.value
            );
          } else if (card.type === "wild") {
            cardDiv.setAttribute(
              "data-value",
              card.value === "wild" ? "W" : "+4"
            );
          }

          // Add card content
          const content = document.createElement("div");
          content.className = "card-content";
          content.style.cssText =
            "display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; z-index: 2; position: relative;";

          if (card.type === "number") {
            const vocabWord = getVocabularyWord(card.color);
            const isLearned = gameState.learnedWords.has(vocabWord);
            content.innerHTML = `
                        <div class="card-number">${card.value}</div>
                        <div class="card-vocabulary" style="color: ${
                          card.color === "yellow" ? "#1a202c" : "white"
                        };">
                          ${vocabWord}${isLearned ? " ✓" : ""}
                        </div>
                    `;
          } else if (card.type === "action") {
            const actionIcons = {
              skip: "fa-ban",
              reverse: "fa-sync-alt",
              draw2: "fa-plus-square",
            };
            content.innerHTML = `
                        <div class="card-icon"><i class="fas ${
                          actionIcons[card.value]
                        }"></i></div>
                        <div class="card-vocabulary">${card.value.toUpperCase()}</div>
                    `;
          } else if (card.type === "wild") {
            const wildIcons = {
              wild: "fa-palette",
              draw4: "fa-plus-circle",
            };

            // Add animated background for wild cards
            const wildBg = document.createElement("div");
            wildBg.className = "wild-bg";
            cardDiv.appendChild(wildBg);

            content.innerHTML = `
                        <div class="card-icon"><i class="fas ${
                          wildIcons[card.value]
                        }"></i></div>
                        <div class="card-vocabulary">${
                          card.value === "wild" ? "WILD" : "DRAW 4"
                        }</div>
                    `;
          }

          cardDiv.appendChild(content);

          // Check if card is playable
          if (isCardPlayable(card)) {
            cardDiv.classList.add("playable");
            cardDiv.onclick = () => playCard(index);

            // Add tooltip for card hints
            if (gameState.showHints) {
              cardDiv.title = `Click to play this ${card.color} ${card.value}`;
            }
          }
        }

        return cardDiv;
      }

      // Get random vocabulary word for color based on difficulty
      function getVocabularyWord(color) {
        if (vocabularyWords[color]) {
          const words = vocabularyWords[color].filter(
            (word) =>
              word.level === difficultyLevel || difficultyLevel === "beginner"
          );
          if (words.length === 0) return "";
          const randomWord = words[Math.floor(Math.random() * words.length)];
          return randomWord.word;
        }
        return "";
      }

      // Get word details for learning
      function getWordDetails(word) {
        for (const color in vocabularyWords) {
          const found = vocabularyWords[color].find((w) => w.word === word);
          if (found) return found;
        }
        return null;
      }

      // Show word learning modal
      function showWordLearning(word) {
        if (!gameState.showHints || gameState.learnedWords.has(word)) return;

        const wordDetails = getWordDetails(word);
        if (!wordDetails) return;

        const wordContent = document.getElementById("wordContent");
        wordContent.innerHTML = `
          <div style="font-size: 2rem; margin-bottom: 0.5rem;">${wordDetails.word}</div>
          <div style="color: var(--primary-color); margin-bottom: 0.5rem;">${wordDetails.pronunciation}</div>
          <div style="color: var(--text-secondary); margin-bottom: 1rem;">${wordDetails.definition}</div>
          <div style="font-size: 0.8rem; color: var(--warning-color);">Level: ${wordDetails.level}</div>
        `;

        gameState.currentLearningWord = word;
        document.getElementById("wordModal").classList.add("show");
      }

      // Mark word as learned
      function markWordLearned() {
        if (gameState.currentLearningWord) {
          gameState.learnedWords.add(gameState.currentLearningWord);
          gameState.wordsLearnedToday++;
          localStorage.setItem(
            "learnedWords",
            JSON.stringify([...gameState.learnedWords])
          );

          // Update challenges
          updateChallengeProgress("learn_words");

          // Check vocabulary expert achievement
          if (gameState.learnedWords.size >= 50) {
            unlockAchievement("vocabularyExpert");
          }
        }
        closeWordModal();
      }

      // Close word modal
      function closeWordModal() {
        document.getElementById("wordModal").classList.remove("show");
        gameState.currentLearningWord = null;
      }

      // Check if card is playable
      function isCardPlayable(card) {
        if (!gameState.playerTurn || gameState.gameOver) return false;

        if (card.type === "wild") return true;

        return (
          card.color === gameState.currentColor ||
          card.value === gameState.currentCard.value
        );
      }

      // Play a card
      function playCard(cardIndex) {
        if (!gameState.playerTurn || gameState.gameOver) return;

        const card = gameState.playerHand[cardIndex];
        if (!isCardPlayable(card)) return;

        // Remove card from player hand
        gameState.playerHand.splice(cardIndex, 1);
        gameState.moveCount++;
        gameState.cardsPlayed++;

        // Update combo
        gameState.combo++;
        if (gameState.combo > gameState.maxCombo) {
          gameState.maxCombo = gameState.combo;
          localStorage.setItem("maxCombo", gameState.maxCombo.toString());
        }

        // Show combo effect
        if (gameState.combo > 1) {
          showComboEffect(gameState.combo);
        }

        // Create card play particles
        if (gameState.animationsEnabled) {
          createParticles(
            document.querySelector(
              `#playerHand .card:nth-child(${cardIndex + 1})`
            )
          );
        }

        // Check for vocabulary learning
        if (card.type === "number") {
          const word = getVocabularyWord(card.color);
          if (word && Math.random() < 0.3) {
            // 30% chance to show word learning
            setTimeout(() => showWordLearning(word), 500);
          }
        }

        // Handle wild cards
        if (card.type === "wild") {
          showColorPicker(card);
          return;
        }

        // Play the card
        executeCardPlay(card);
        playSound("cardPlay");

        // Check card shark achievement
        if (gameState.cardsPlayed >= 100) {
          unlockAchievement("cardShark");
        }
      }

      // Execute card play
      function executeCardPlay(card) {
        gameState.currentCard = card;
        gameState.currentColor = card.color;
        gameState.discardPile.push(card);

        // Handle action cards
        if (card.type === "action") {
          handleActionCard(card);
        } else if (card.type === "wild" && card.value === "draw4") {
          // Computer draws 4 cards
          for (let i = 0; i < 4; i++) {
            if (gameState.deck.length === 0) reshuffleDeck();
            gameState.computerHand.push(gameState.deck.pop());
          }
          playSound("draw");
        }

        // Check for UNO
        if (gameState.playerHand.length === 1) {
          showUnoButton();
        }

        // Check for win
        if (gameState.playerHand.length === 0) {
          endGame(true);
          return;
        }

        // Switch turns
        gameState.playerTurn = false;
        updateDisplay();

        // Computer's turn
        setTimeout(computerTurn, 1000);
      }

      // Handle action cards
      function handleActionCard(card) {
        switch (card.value) {
          case "skip":
            playSound("skip");
            break;
          case "reverse":
            playSound("reverse");
            break;
          case "draw2":
            // Computer draws 2 cards
            for (let i = 0; i < 2; i++) {
              if (gameState.deck.length === 0) reshuffleDeck();
              gameState.computerHand.push(gameState.deck.pop());
            }
            playSound("draw");
            break;
        }
      }

      // Show color picker
      function showColorPicker(card) {
        gameState.pendingWildCard = card;
        document.getElementById("colorPicker").classList.add("show");
      }

      // Select color for wild card
      function selectColor(color) {
        const card = gameState.pendingWildCard;
        card.color = color;
        gameState.currentColor = color;

        document.getElementById("colorPicker").classList.remove("show");
        executeCardPlay(card);
      }

      // Computer turn with improved AI
      function computerTurn() {
        if (gameState.gameOver) return;

        gameState.computerThinking = true;
        updateDisplay();
        updateTurnIndicator();

        // Smart AI delay based on difficulty
        const thinkingTime =
          difficultyLevel === "beginner"
            ? 800
            : difficultyLevel === "intermediate"
            ? 1200
            : 1800;

        setTimeout(() => {
          const playableCards = gameState.computerHand.filter(
            (card) =>
              card.type === "wild" ||
              card.color === gameState.currentColor ||
              card.value === gameState.currentCard.value
          );

          if (playableCards.length > 0) {
            // Improved AI strategy based on difficulty
            let cardToPlay;

            if (difficultyLevel === "advanced") {
              // Advanced: Strategic play
              cardToPlay =
                getBestComputerCard(playableCards) || playableCards[0];
            } else if (difficultyLevel === "intermediate") {
              // Intermediate: Somewhat strategic
              cardToPlay =
                playableCards.find((card) => card.type === "action") ||
                playableCards[0];
            } else {
              // Beginner: Random play
              cardToPlay =
                playableCards[Math.floor(Math.random() * playableCards.length)];
            }

            const cardIndex = gameState.computerHand.indexOf(cardToPlay);
            gameState.computerHand.splice(cardIndex, 1);

            // Handle wild cards
            if (cardToPlay.type === "wild") {
              const randomColor =
                colors[Math.floor(Math.random() * colors.length)];
              cardToPlay.color = randomColor;
              gameState.currentColor = randomColor;
            }

            gameState.currentCard = cardToPlay;
            if (cardToPlay.type !== "wild") {
              gameState.currentColor = cardToPlay.color;
            }
            gameState.discardPile.push(cardToPlay);

            // Handle action cards against player
            if (cardToPlay.type === "action") {
              handleComputerActionCard(cardToPlay);
            } else if (
              cardToPlay.type === "wild" &&
              cardToPlay.value === "draw4"
            ) {
              // Player draws 4 cards
              for (let i = 0; i < 4; i++) {
                if (gameState.deck.length === 0) reshuffleDeck();
                gameState.playerHand.push(gameState.deck.pop());
              }
              playSound("draw");
            }

            // Check for computer UNO
            if (gameState.computerHand.length === 1) {
              gameState.computerCalledUno = true;
              showMessage(
                "Computer called UNO!",
                "The computer has one card left!"
              );
              playSound("uno");
            }

            // Check for computer win
            if (gameState.computerHand.length === 0) {
              endGame(false);
              return;
            }

            playSound("cardPlay");
          } else {
            // Draw a card
            if (gameState.deck.length === 0) reshuffleDeck();
            gameState.computerHand.push(gameState.deck.pop());
            playSound("draw");
          }

          gameState.computerThinking = false;
          gameState.playerTurn = true;
          gameState.combo = 0; // Reset combo when turn switches
          updateDisplay();
          checkForPlayableCards();

          // Show hints if enabled
          if (gameState.showHints) {
            showPlayHints();
          }
        }, thinkingTime);
      }

      // Get best computer card (advanced AI with card counting)
      function getBestComputerCard(playableCards) {
        if (difficultyLevel === "advanced") {
          // Advanced AI: Card counting and strategic play

          // 1. Prioritize getting rid of high-value cards
          const actionCards = playableCards.filter(
            (card) => card.type === "action"
          );
          const wildCards = playableCards.filter(
            (card) => card.type === "wild"
          );
          const numberCards = playableCards.filter(
            (card) => card.type === "number"
          );

          // 2. If close to winning, use wild cards strategically
          if (gameState.computerHand.length <= 2 && wildCards.length > 0) {
            return wildCards[0];
          }

          // 3. Use action cards to disrupt player
          if (gameState.playerHand.length <= 3 && actionCards.length > 0) {
            // Prioritize draw cards when player is close to winning
            const drawCards = actionCards.filter(
              (card) => card.value === "draw2"
            );
            if (drawCards.length > 0) return drawCards[0];
            return actionCards[0];
          }

          // 4. Count colors in hand to make strategic choices
          const colorCounts = {};
          gameState.computerHand.forEach((card) => {
            if (card.color !== "wild") {
              colorCounts[card.color] = (colorCounts[card.color] || 0) + 1;
            }
          });

          // 5. Prefer cards of colors we have more of
          if (numberCards.length > 0) {
            const sortedByColorCount = numberCards.sort(
              (a, b) =>
                (colorCounts[b.color] || 0) - (colorCounts[a.color] || 0)
            );
            return sortedByColorCount[0];
          }

          return playableCards[0];
        }

        // Original logic for other difficulties
        const actionCards = playableCards.filter(
          (card) => card.type === "action"
        );
        if (actionCards.length > 0) return actionCards[0];

        const wildCards = playableCards.filter((card) => card.type === "wild");
        if (wildCards.length > 0 && gameState.computerHand.length > 3)
          return wildCards[0];

        const numberCards = playableCards.filter(
          (card) => card.type === "number"
        );
        if (numberCards.length > 0) {
          return numberCards.reduce((max, card) =>
            card.value > max.value ? card : max
          );
        }

        return playableCards[0];
      }

      // Handle computer action cards
      function handleComputerActionCard(card) {
        switch (card.value) {
          case "skip":
            playSound("skip");
            break;
          case "reverse":
            playSound("reverse");
            break;
          case "draw2":
            // Player draws 2 cards
            for (let i = 0; i < 2; i++) {
              if (gameState.deck.length === 0) reshuffleDeck();
              gameState.playerHand.push(gameState.deck.pop());
            }
            playSound("draw");
            break;
        }
      }

      // Draw card
      function drawCard() {
        if (!gameState.playerTurn || gameState.gameOver) return;

        if (gameState.deck.length === 0) reshuffleDeck();

        const drawnCard = gameState.deck.pop();
        gameState.playerHand.push(drawnCard);
        gameState.moveCount++;

        playSound("draw");
        updateDisplay();

        // Check if drawn card is playable
        if (isCardPlayable(drawnCard)) {
          // Player can choose to play it immediately
          const cardIndex = gameState.playerHand.length - 1;
          setTimeout(() => {
            const cardElement = document.querySelector(
              `#playerHand .card:nth-child(${cardIndex + 1})`
            );
            if (cardElement) {
              cardElement.style.animation = "glow 1s infinite alternate";
            }
          }, 500);
        } else {
          // End turn
          gameState.playerTurn = false;
          setTimeout(computerTurn, 1000);
        }
      }

      // Reshuffle deck
      function reshuffleDeck() {
        if (gameState.discardPile.length <= 1) return;

        const currentCard = gameState.discardPile.pop();
        gameState.deck = [...gameState.discardPile];
        gameState.discardPile = [currentCard];
        shuffleDeck();
      }

      // Check for playable cards
      function checkForPlayableCards() {
        const hasPlayableCard = gameState.playerHand.some((card) =>
          isCardPlayable(card)
        );
        document.getElementById("drawBtn").disabled =
          !gameState.playerTurn || gameState.gameOver;
      }

      // Update current card display
      function updateCurrentCard() {
        const currentCardElement = document.getElementById("currentCard");
        const card = gameState.currentCard;

        if (card) {
          currentCardElement.className = `card current-card ${card.color}`;

          // Add data attribute for corner display
          if (card.type === "number") {
            currentCardElement.setAttribute("data-value", card.value);
          } else if (card.type === "action") {
            const actionSymbols = { skip: "⊘", reverse: "↻", draw2: "+2" };
            currentCardElement.setAttribute(
              "data-value",
              actionSymbols[card.value] || card.value
            );
          } else if (card.type === "wild") {
            currentCardElement.setAttribute(
              "data-value",
              card.value === "wild" ? "W" : "+4"
            );
          }

          let content = "";
          const textColor = card.color === "yellow" ? "#1a202c" : "white";

          if (card.type === "number") {
            content = `
                        <div class="card-content" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; z-index: 2; position: relative;">
                            <div class="card-number">${card.value}</div>
                            <div class="card-vocabulary" style="color: ${textColor};">${getVocabularyWord(
              card.color
            )}</div>
                        </div>
                    `;
          } else if (card.type === "action") {
            const actionIcons = {
              skip: "fa-ban",
              reverse: "fa-sync-alt",
              draw2: "fa-plus-square",
            };
            content = `
                        <div class="card-content" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; z-index: 2; position: relative;">
                            <div class="card-icon"><i class="fas ${
                              actionIcons[card.value]
                            }"></i></div>
                            <div class="card-vocabulary" style="color: ${textColor};">${card.value.toUpperCase()}</div>
                        </div>
                    `;
          } else if (card.type === "wild") {
            const wildIcons = {
              wild: "fa-palette",
              draw4: "fa-plus-circle",
            };
            content = `
                        <div class="wild-bg"></div>
                        <div class="card-content" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; z-index: 2; position: relative;">
                            <div class="card-icon"><i class="fas ${
                              wildIcons[card.value]
                            }"></i></div>
                            <div class="card-vocabulary">${
                              card.value === "wild" ? "WILD" : "DRAW 4"
                            }</div>
                        </div>
                    `;
          }

          currentCardElement.innerHTML = content;

          // Update color indicator
          document.getElementById(
            "currentColor"
          ).textContent = `Color: ${gameState.currentColor}`;
        }
      }

      // Update game status
      function updateGameStatus() {
        document.getElementById(
          "playerCardCount"
        ).textContent = `${gameState.playerHand.length} cards`;
        document.getElementById(
          "computerCardCount"
        ).textContent = `${gameState.computerHand.length} cards`;
        document.getElementById(
          "deckCount"
        ).textContent = `Cards: ${gameState.deck.length}`;
        document.getElementById(
          "playerCombo"
        ).textContent = `Combo: ${gameState.combo}`;
        document.getElementById("difficultyDisplay").textContent =
          difficultyLevel.charAt(0).toUpperCase() + difficultyLevel.slice(1);
        updateTurnIndicator();
      }

      // Update turn indicator
      function updateTurnIndicator() {
        const indicator = document.getElementById("turnIndicator");
        if (gameState.gameOver) {
          indicator.textContent = "Game Over";
          indicator.className = "turn-indicator";
        } else if (gameState.computerThinking) {
          indicator.textContent = "Computer Thinking...";
          indicator.className = "turn-indicator thinking-indicator";
        } else if (gameState.playerTurn) {
          indicator.textContent = "Your Turn";
          indicator.className = "turn-indicator";
        } else {
          indicator.textContent = "Computer's Turn";
          indicator.className = "turn-indicator thinking-indicator";
        }
      }

      // Show/hide UNO button
      function showUnoButton() {
        document.getElementById("unoBtn").style.display = "block";
      }

      function updateUnoButton() {
        const unoBtn = document.getElementById("unoBtn");
        if (gameState.playerHand.length === 1 && !gameState.playerCalledUno) {
          unoBtn.style.display = "block";
        } else {
          unoBtn.style.display = "none";
        }
      }

      // Call UNO
      function callUno() {
        if (gameState.playerHand.length === 1) {
          gameState.playerCalledUno = true;
          showMessage("UNO!", "You called UNO with one card left!");
          playSound("uno");
          updateUnoButton();
        }
      }

      // End game
      function endGame(playerWon) {
        gameState.gameOver = true;
        gameState.stats.gamesPlayed++;

        const gameTime = Date.now() - gameState.gameStartTime;

        if (playerWon) {
          gameState.stats.gamesWon++;

          // Update challenges
          updateChallengeProgress("win_games");
          if (gameTime < 90000) {
            // Under 90 seconds
            updateChallengeProgress("fast_game");
          }

          // Check for fast win achievement
          if (gameTime < 120000) {
            // 2 minutes
            unlockAchievement("fastWin");
          }

          // Update fastest win
          if (gameTime < gameState.stats.fastestWin) {
            gameState.stats.fastestWin = gameTime;
            localStorage.setItem("fastestWin", gameTime.toString());
          }

          // Check for first win achievement
          if (gameState.stats.gamesWon === 1) {
            unlockAchievement("firstWin");
          }

          // Check for UNO master achievement
          if (gameState.stats.gamesWon >= 10) {
            unlockAchievement("unoMaster");
          }

          showMessage(
            "🎉 Congratulations!",
            `You won in ${Math.round(gameTime / 1000)}s with ${
              gameState.moveCount
            } moves!`
          );
          playSound("win");
        } else {
          showMessage("😞 Game Over", "Computer wins this time. Try again! 🤖");
          playSound("lose");
        }

        // Update statistics
        gameState.stats.totalTime += gameTime;
        localStorage.setItem("cardsPlayed", gameState.cardsPlayed.toString());
        saveStats();
        updateDisplay();
      }

      // Show message
      function showMessage(title, text) {
        document.getElementById("messageTitle").textContent = title;
        document.getElementById("messageText").textContent = text;
        document.getElementById("gameMessage").classList.add("show");
      }

      // Close message
      function closeMessage() {
        document.getElementById("gameMessage").classList.remove("show");
      }

      // New game
      function newGame() {
        gameState = {
          playerHand: [],
          computerHand: [],
          deck: [],
          discardPile: [],
          currentCard: null,
          currentColor: null,
          playerTurn: true,
          gameOver: false,
          playerCalledUno: false,
          computerCalledUno: false,
          computerThinking: false,
          gameStartTime: null,
          moveCount: 0,
          soundEnabled: gameState.soundEnabled,
          stats: gameState.stats,
        };

        closeMessage();
        initGame();
      }

      // Game timer
      function startGameTimer() {
        setInterval(() => {
          if (!gameState.gameOver && gameState.gameStartTime) {
            const elapsed = Date.now() - gameState.gameStartTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            document.getElementById(
              "gameTimer"
            ).textContent = `Time: ${minutes}:${seconds
              .toString()
              .padStart(2, "0")}`;
            document.getElementById(
              "moveCount"
            ).textContent = `Moves: ${gameState.moveCount}`;
          }
        }, 1000);
      }

      // Enhanced sound effects
      function playSound(type) {
        if (!gameState.soundEnabled) return;

        // Create audio context for sound effects
        const audioContext = new (window.AudioContext ||
          window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);

        switch (type) {
          case "cardPlay":
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + 0.2
            );
            break;
          case "draw":
            oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + 0.3
            );
            break;
          case "uno":
            // Create a more exciting UNO sound
            oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
            oscillator.frequency.linearRampToValueAtTime(
              1320,
              audioContext.currentTime + 0.2
            );
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + 0.4
            );
            break;
          case "win":
            // Victory fanfare
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
            oscillator.frequency.linearRampToValueAtTime(
              880,
              audioContext.currentTime + 0.2
            );
            oscillator.frequency.linearRampToValueAtTime(
              660,
              audioContext.currentTime + 0.4
            );
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + 0.6
            );
            break;
          case "lose":
            oscillator.frequency.setValueAtTime(165, audioContext.currentTime);
            oscillator.frequency.linearRampToValueAtTime(
              110,
              audioContext.currentTime + 0.3
            );
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + 0.5
            );
            break;
          case "skip":
            oscillator.frequency.setValueAtTime(330, audioContext.currentTime);
            oscillator.frequency.linearRampToValueAtTime(
              440,
              audioContext.currentTime + 0.1
            );
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + 0.2
            );
            break;
          case "reverse":
            oscillator.frequency.setValueAtTime(550, audioContext.currentTime);
            oscillator.frequency.linearRampToValueAtTime(
              330,
              audioContext.currentTime + 0.15
            );
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + 0.25
            );
            break;
          case "achievement":
            // Special achievement sound
            oscillator.frequency.setValueAtTime(523, audioContext.currentTime); // C5
            oscillator.frequency.linearRampToValueAtTime(
              659,
              audioContext.currentTime + 0.1
            ); // E5
            oscillator.frequency.linearRampToValueAtTime(
              784,
              audioContext.currentTime + 0.2
            ); // G5
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + 0.5
            );
            break;
        }

        const duration =
          type === "win"
            ? 0.6
            : type === "achievement"
            ? 0.5
            : type === "uno"
            ? 0.4
            : 0.3;
        oscillator.start();
        oscillator.stop(audioContext.currentTime + duration);
      }

      // Toggle sound
      function toggleSound() {
        gameState.soundEnabled = !gameState.soundEnabled;
        const icon = document.querySelector("#soundToggle i");
        icon.className = gameState.soundEnabled
          ? "fas fa-volume-up"
          : "fas fa-volume-mute";
      }

      // Show rules
      function showRules() {
        const rulesText = `
                UNO Rules:
                • Match the color or number of the current card
                • Taew says no cheating!
                • Action cards: Skip, Reverse, Draw Two
                • Wild cards can be played anytime
                • Call UNO when you have one card left
                • First to play all cards wins!

                ESL Features:
                • Learn vocabulary with each card
                • Practice pronunciation
                • Improve English while playing!
            `;
        showMessage("Game Rules", rulesText);
      }

      // Show statistics
      function showStats() {
        const winRate =
          gameState.stats.gamesPlayed > 0
            ? Math.round(
                (gameState.stats.gamesWon / gameState.stats.gamesPlayed) * 100
              )
            : 0;
        const avgTime =
          gameState.stats.gamesPlayed > 0
            ? Math.round(
                gameState.stats.totalTime / gameState.stats.gamesPlayed / 1000
              )
            : 0;

        const statsText = `
                Your Statistics:
                • Games Played: ${gameState.stats.gamesPlayed}
                • Games Won: ${gameState.stats.gamesWon}
                • Win Rate: ${winRate}%
                • Average Game Time: ${avgTime}s
            `;
        showMessage("Your Stats", statsText);
      }

      // Save statistics
      function saveStats() {
        localStorage.setItem(
          "gamesPlayed",
          gameState.stats.gamesPlayed.toString()
        );
        localStorage.setItem("gamesWon", gameState.stats.gamesWon.toString());
        localStorage.setItem("totalTime", gameState.stats.totalTime.toString());
      }

      // Show combo effect
      function showComboEffect(combo) {
        const comboDiv = document.createElement("div");
        comboDiv.className = "combo-indicator";
        comboDiv.innerHTML = `🔥 ${combo}x COMBO! 🔥`;
        document.body.appendChild(comboDiv);

        setTimeout(() => {
          document.body.removeChild(comboDiv);
        }, 2000);
      }

      // Create particle effects
      function createParticles(element) {
        if (!element) return;

        const rect = element.getBoundingClientRect();
        const colors = ["#ff6b6b", "#4ecdc4", "#45b7d1", "#f9ca24"];

        for (let i = 0; i < 8; i++) {
          const particle = document.createElement("div");
          particle.className = "particle";
          particle.style.position = "fixed";
          particle.style.left = rect.left + rect.width / 2 + "px";
          particle.style.top = rect.top + rect.height / 2 + "px";
          particle.style.width = "8px";
          particle.style.height = "8px";
          particle.style.background =
            colors[Math.floor(Math.random() * colors.length)];
          particle.style.transform = `translate(${
            Math.random() * 100 - 50
          }px, ${Math.random() * 100 - 50}px)`;

          document.body.appendChild(particle);

          setTimeout(() => {
            if (particle.parentNode) {
              document.body.removeChild(particle);
            }
          }, 1000);
        }
      }

      // Show play hints
      function showPlayHints() {
        if (!gameState.showHints || !gameState.playerTurn) return;

        const playableCards = document.querySelectorAll(".card.playable");
        if (playableCards.length === 0) {
          // Show draw hint
          const drawBtn = document.getElementById("drawBtn");
          showHint(drawBtn, "No playable cards! Draw one.");
        } else if (playableCards.length === 1) {
          showHint(playableCards[0], "Only one card to play!");
        }
      }

      // Show hint
      function showHint(element, text) {
        const hint = document.createElement("div");
        hint.className = "hint-overlay";
        hint.textContent = text;
        element.style.position = "relative";
        element.appendChild(hint);

        setTimeout(() => {
          if (hint.parentNode) {
            element.removeChild(hint);
          }
        }, 3000);
      }

      // Achievement system
      function unlockAchievement(key) {
        if (achievements[key].unlocked) return;

        achievements[key].unlocked = true;
        localStorage.setItem(`achievement_${key}`, "true");
        showAchievementNotification(achievements[key]);
      }

      // Show achievement notification
      function showAchievementNotification(achievement) {
        const notification = document.createElement("div");
        notification.className = "achievement-notification";
        notification.innerHTML = `
          <div style="display: flex; align-items: center; gap: 0.5rem;">
            <i class="fas fa-trophy" style="font-size: 1.5rem;"></i>
            <div>
              <div style="font-weight: bold;">Achievement Unlocked!</div>
              <div style="font-size: 0.9rem;">${achievement.name}</div>
              <div style="font-size: 0.8rem; opacity: 0.8;">${achievement.description}</div>
            </div>
          </div>
        `;

        document.body.appendChild(notification);

        setTimeout(() => {
          if (notification.parentNode) {
            document.body.removeChild(notification);
          }
        }, 4000);

        playSound("achievement");
      }

      // Settings functions
      function showSettings() {
        document.getElementById("difficultySelect").value = difficultyLevel;
        document.getElementById("soundToggleCheck").checked =
          gameState.soundEnabled;
        document.getElementById("animationsToggleCheck").checked =
          gameState.animationsEnabled;
        document.getElementById("hintsToggleCheck").checked =
          gameState.showHints;
        document.getElementById("settingsModal").classList.add("show");
      }

      function saveSettings() {
        difficultyLevel = document.getElementById("difficultySelect").value;
        gameState.soundEnabled =
          document.getElementById("soundToggleCheck").checked;
        gameState.animationsEnabled = document.getElementById(
          "animationsToggleCheck"
        ).checked;
        gameState.showHints =
          document.getElementById("hintsToggleCheck").checked;

        localStorage.setItem("unodifficulty", difficultyLevel);
        localStorage.setItem("unosound", gameState.soundEnabled.toString());
        localStorage.setItem(
          "unoanimations",
          gameState.animationsEnabled.toString()
        );
        localStorage.setItem("unohints", gameState.showHints.toString());

        closeSettings();
        updateDisplay();
      }

      function closeSettings() {
        document.getElementById("settingsModal").classList.remove("show");
      }

      // Achievements functions
      function showAchievements() {
        const achievementsList = document.getElementById("achievementsList");
        achievementsList.innerHTML = "";

        Object.entries(achievements).forEach(([key, achievement]) => {
          const achievementDiv = document.createElement("div");
          achievementDiv.style.cssText =
            "display: flex; align-items: center; gap: 1rem; padding: 0.8rem; margin-bottom: 0.5rem; background: rgba(79, 70, 229, 0.1); border-radius: 10px;";

          const icon = achievement.unlocked ? "🏆" : "🔒";
          const opacity = achievement.unlocked ? "1" : "0.5";

          achievementDiv.innerHTML = `
            <div style="font-size: 1.5rem; opacity: ${opacity};">${icon}</div>
            <div style="opacity: ${opacity};">
              <div style="font-weight: bold; margin-bottom: 0.2rem;">${achievement.name}</div>
              <div style="font-size: 0.9rem; color: var(--text-secondary);">${achievement.description}</div>
            </div>
          `;

          achievementsList.appendChild(achievementDiv);
        });

        document.getElementById("achievementsModal").classList.add("show");
      }

      function closeAchievements() {
        document.getElementById("achievementsModal").classList.remove("show");
      }

      // Vocabulary Quiz System
      function showVocabularyQuiz() {
        gameState.quiz.score = 0;
        gameState.quiz.totalQuestions = 0;
        generateQuizQuestion();
        document.getElementById("vocabularyQuizModal").classList.add("show");
      }

      function generateQuizQuestion() {
        // Get all words from current difficulty level
        const allWords = [];
        Object.values(vocabularyWords).forEach((colorWords) => {
          colorWords
            .filter(
              (word) =>
                word.level === difficultyLevel || difficultyLevel === "beginner"
            )
            .forEach((word) => allWords.push(word));
        });

        if (allWords.length < 3) return;

        // Pick a random word
        const correctWord =
          allWords[Math.floor(Math.random() * allWords.length)];
        gameState.quiz.currentQuestion = correctWord;

        // Generate wrong options
        const wrongWords = allWords.filter((w) => w.word !== correctWord.word);
        const option1 =
          wrongWords[Math.floor(Math.random() * wrongWords.length)];
        const option2 = wrongWords.filter((w) => w.word !== option1.word)[
          Math.floor(Math.random() * (wrongWords.length - 1))
        ];

        // Randomize answer position
        gameState.quiz.correctAnswer = Math.floor(Math.random() * 3);
        gameState.quiz.options = [];

        for (let i = 0; i < 3; i++) {
          if (i === gameState.quiz.correctAnswer) {
            gameState.quiz.options[i] = correctWord;
          } else {
            gameState.quiz.options[i] =
              i === 0 || (i === 1 && gameState.quiz.correctAnswer !== 0)
                ? option1
                : option2;
          }
        }

        // Update quiz UI
        document.getElementById("quizContent").innerHTML = `
          <div style="font-size: 1.2rem; margin-bottom: 1rem;">What does this word mean?</div>
          <div style="font-size: 2rem; color: var(--primary-color); margin-bottom: 0.5rem;">${
            correctWord.word
          }</div>
          <div style="color: var(--text-secondary); margin-bottom: 1.5rem;">${
            correctWord.pronunciation
          }</div>
          <div style="margin-bottom: 1rem;">Category: ${
            correctWord.category || "General"
          }</div>
        `;

        document.getElementById("quizOption1").textContent =
          gameState.quiz.options[0].definition;
        document.getElementById("quizOption2").textContent =
          gameState.quiz.options[1].definition;
        document.getElementById("quizOption3").textContent =
          gameState.quiz.options[2].definition;

        updateQuizScore();
      }

      function selectQuizAnswer(optionIndex) {
        gameState.quiz.totalQuestions++;

        if (optionIndex === gameState.quiz.correctAnswer) {
          gameState.quiz.score++;
          showQuizFeedback(true);
          playSound("achievement");

          // Add to learned words
          const word = gameState.quiz.currentQuestion.word;
          if (!gameState.learnedWords.has(word)) {
            gameState.learnedWords.add(word);
            gameState.wordsLearnedToday++;
            updateWordProgress(word, true);
          }
        } else {
          showQuizFeedback(false);
          playSound("lose");
          updateWordProgress(gameState.quiz.currentQuestion.word, false);
        }

        updateQuizScore();

        // Generate next question after delay
        setTimeout(() => {
          if (gameState.quiz.totalQuestions < 10) {
            generateQuizQuestion();
          } else {
            showQuizResults();
          }
        }, 2000);
      }

      function showQuizFeedback(correct) {
        const buttons = document.querySelectorAll(
          "#vocabularyQuizModal button[id^='quizOption']"
        );
        buttons.forEach((btn, index) => {
          if (index === gameState.quiz.correctAnswer) {
            btn.style.background = "#10b981"; // Green for correct
          } else if (!correct && index === gameState.quiz.correctAnswer) {
            btn.style.background = "#ef4444"; // Red for wrong selection
          }
          btn.disabled = true;
        });

        // Reset button styles after delay
        setTimeout(() => {
          buttons.forEach((btn) => {
            btn.style.background = "var(--primary-color)";
            btn.disabled = false;
          });
        }, 2000);
      }

      function updateQuizScore() {
        document.getElementById(
          "quizScore"
        ).textContent = `Score: ${gameState.quiz.score}/${gameState.quiz.totalQuestions}`;
      }

      function showQuizResults() {
        const percentage = Math.round(
          (gameState.quiz.score / gameState.quiz.totalQuestions) * 100
        );
        let message = "";

        if (percentage >= 80) {
          message = "🎉 Excellent work! You're mastering these words!";
          updateChallengeProgress("quiz_master"); // Award challenge progress for high score
        } else if (percentage >= 60) {
          message = "👍 Good job! Keep practicing to improve.";
        } else {
          message = "📚 Keep studying! Practice makes perfect.";
        }

        document.getElementById("quizContent").innerHTML = `
          <div style="font-size: 1.5rem; margin-bottom: 1rem;">Quiz Complete!</div>
          <div style="font-size: 2rem; color: var(--primary-color); margin-bottom: 1rem;">${gameState.quiz.score}/${gameState.quiz.totalQuestions}</div>
          <div style="font-size: 1.2rem; margin-bottom: 1rem;">${percentage}%</div>
          <div style="color: var(--text-secondary);">${message}</div>
        `;

        // Hide option buttons
        document
          .querySelectorAll("#vocabularyQuizModal button[id^='quizOption']")
          .forEach((btn) => {
            btn.style.display = "none";
          });

        // Save progress
        localStorage.setItem(
          "learnedWords",
          JSON.stringify([...gameState.learnedWords])
        );
        localStorage.setItem(
          "wordProgress",
          JSON.stringify(gameState.wordProgress)
        );
      }

      function closeVocabularyQuiz() {
        document.getElementById("vocabularyQuizModal").classList.remove("show");
        // Reset option buttons
        document
          .querySelectorAll("#vocabularyQuizModal button[id^='quizOption']")
          .forEach((btn) => {
            btn.style.display = "inline-block";
          });
      }

      // Word Progress Tracking
      function updateWordProgress(word, correct) {
        if (!gameState.wordProgress[word]) {
          gameState.wordProgress[word] = {
            attempts: 0,
            correct: 0,
            lastSeen: Date.now(),
            streak: 0,
          };
        }

        const progress = gameState.wordProgress[word];
        progress.attempts++;
        progress.lastSeen = Date.now();

        if (correct) {
          progress.correct++;
          progress.streak++;
        } else {
          progress.streak = 0;
        }

        localStorage.setItem(
          "wordProgress",
          JSON.stringify(gameState.wordProgress)
        );
      }

      function showWordProgress() {
        const progressContent = document.getElementById("progressContent");
        let content = `
          <div style="margin-bottom: 1rem;">
            <h3>📊 Learning Statistics</h3>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1rem;">
              <div style="background: rgba(79, 70, 229, 0.1); padding: 0.8rem; border-radius: 8px;">
                <div style="font-size: 1.2rem; font-weight: bold;">${
                  gameState.learnedWords.size
                }</div>
                <div style="font-size: 0.9rem; color: var(--text-secondary);">Words Learned</div>
              </div>
              <div style="background: rgba(16, 185, 129, 0.1); padding: 0.8rem; border-radius: 8px;">
                <div style="font-size: 1.2rem; font-weight: bold;">${
                  gameState.wordsLearnedToday
                }</div>
                <div style="font-size: 0.9rem; color: var(--text-secondary);">Today's Progress</div>
              </div>
            </div>
          </div>
          <div style="margin-bottom: 1rem;">
            <h3>🎯 Daily Goal: ${gameState.wordsLearnedToday}/${
          gameState.dailyGoal
        }</h3>
            <div style="background: #e5e7eb; border-radius: 10px; overflow: hidden; height: 8px;">
              <div style="background: var(--success-color); height: 100%; width: ${Math.min(
                (gameState.wordsLearnedToday / gameState.dailyGoal) * 100,
                100
              )}%;"></div>
            </div>
          </div>
        `;

        // Show word mastery levels
        if (Object.keys(gameState.wordProgress).length > 0) {
          content += `<div><h3>📚 Word Mastery</h3>`;

          Object.entries(gameState.wordProgress)
            .sort(([, a], [, b]) => b.correct - a.correct)
            .slice(0, 10)
            .forEach(([word, progress]) => {
              const accuracy = Math.round(
                (progress.correct / progress.attempts) * 100
              );
              const masteryLevel =
                progress.streak >= 3
                  ? "🏆 Mastered"
                  : progress.streak >= 2
                  ? "⭐ Good"
                  : accuracy >= 70
                  ? "👍 Learning"
                  : "📚 Practice";

              content += `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; margin-bottom: 0.5rem; background: rgba(0,0,0,0.05); border-radius: 8px;">
                  <div>
                    <div style="font-weight: bold;">${word}</div>
                    <div style="font-size: 0.8rem; color: var(--text-secondary);">${progress.correct}/${progress.attempts} correct (${accuracy}%)</div>
                  </div>
                  <div style="font-size: 0.8rem;">${masteryLevel}</div>
                </div>
              `;
            });

          content += `</div>`;
        }

        progressContent.innerHTML = content;
        document.getElementById("wordProgressModal").classList.add("show");
      }

      function closeWordProgress() {
        document.getElementById("wordProgressModal").classList.remove("show");
      }

      // Daily Challenges System
      function generateDailyChallenges() {
        const today = new Date().toDateString();
        if (gameState.dailyChallenges.lastReset !== today) {
          // Generate new challenges for today
          const challenges = [
            {
              id: "win_games",
              title: "Victory Challenge",
              description: "Win 2 games today",
              target: 2,
              progress: 0,
              reward: "3 Hint Power-ups",
              icon: "🏆",
            },
            {
              id: "learn_words",
              title: "Word Master",
              description: "Learn 8 new words today",
              target: 8,
              progress: 0,
              reward: "2 Peek Cards Power-ups",
              icon: "📚",
            },
            {
              id: "fast_game",
              title: "Speed Demon",
              description: "Win a game in under 90 seconds",
              target: 1,
              progress: 0,
              reward: "1 Skip Turn Power-up",
              icon: "⚡",
            },
            {
              id: "quiz_master",
              title: "Quiz Champion",
              description: "Score 80% or higher on vocabulary quiz",
              target: 1,
              progress: 0,
              reward: "1 Extra Time Power-up",
              icon: "🧠",
            },
          ];

          gameState.dailyChallenges.current = challenges;
          gameState.dailyChallenges.completed = [];
          gameState.dailyChallenges.lastReset = today;

          localStorage.setItem("dailyChallenges", JSON.stringify(challenges));
          localStorage.setItem("completedChallenges", JSON.stringify([]));
          localStorage.setItem("challengesLastReset", today);
        }
      }

      function updateChallengeProgress(challengeId, increment = 1) {
        const challenge = gameState.dailyChallenges.current.find(
          (c) => c.id === challengeId
        );
        if (
          challenge &&
          !gameState.dailyChallenges.completed.includes(challengeId)
        ) {
          challenge.progress = Math.min(
            challenge.progress + increment,
            challenge.target
          );

          if (challenge.progress >= challenge.target) {
            completeDailyChallenge(challengeId);
          }

          localStorage.setItem(
            "dailyChallenges",
            JSON.stringify(gameState.dailyChallenges.current)
          );
        }
      }

      function completeDailyChallenge(challengeId) {
        if (gameState.dailyChallenges.completed.includes(challengeId)) return;

        gameState.dailyChallenges.completed.push(challengeId);
        const challenge = gameState.dailyChallenges.current.find(
          (c) => c.id === challengeId
        );

        if (challenge) {
          // Award power-ups based on challenge
          switch (challengeId) {
            case "win_games":
              gameState.powerUps.hints += 3;
              break;
            case "learn_words":
              gameState.powerUps.peekCards += 2;
              break;
            case "fast_game":
              gameState.powerUps.skipTurn += 1;
              break;
            case "quiz_master":
              gameState.powerUps.extraTime += 1;
              break;
          }

          savePowerUps();
          showChallengeCompleteNotification(challenge);
        }

        localStorage.setItem(
          "completedChallenges",
          JSON.stringify(gameState.dailyChallenges.completed)
        );
      }

      function showChallengeCompleteNotification(challenge) {
        const notification = document.createElement("div");
        notification.className = "achievement-notification";
        notification.style.background =
          "linear-gradient(135deg, #10b981, #34d399)";
        notification.innerHTML = `
          <div style="display: flex; align-items: center; gap: 0.5rem;">
            <div style="font-size: 1.5rem;">${challenge.icon}</div>
            <div>
              <div style="font-weight: bold; color: white;">Challenge Complete!</div>
              <div style="font-size: 0.9rem; color: rgba(255,255,255,0.9);">${challenge.title}</div>
              <div style="font-size: 0.8rem; color: rgba(255,255,255,0.8);">Reward: ${challenge.reward}</div>
            </div>
          </div>
        `;

        document.body.appendChild(notification);
        playSound("achievement");

        setTimeout(() => {
          if (notification.parentNode) {
            document.body.removeChild(notification);
          }
        }, 4000);
      }

      function showDailyChallenges() {
        generateDailyChallenges();
        const challengesContent = document.getElementById("challengesContent");

        let content = `
          <div style="margin-bottom: 1rem;">
            <h3>Today's Challenges</h3>
            <p style="color: var(--text-secondary); font-size: 0.9rem;">Complete challenges to earn power-ups!</p>
          </div>
        `;

        gameState.dailyChallenges.current.forEach((challenge) => {
          const isCompleted = gameState.dailyChallenges.completed.includes(
            challenge.id
          );
          const progressPercent = (challenge.progress / challenge.target) * 100;

          content += `
            <div style="margin-bottom: 1rem; padding: 1rem; border-radius: 10px; background: ${
              isCompleted ? "rgba(16, 185, 129, 0.1)" : "rgba(79, 70, 229, 0.1)"
            };">
              <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                <span style="font-size: 1.2rem;">${challenge.icon}</span>
                <div style="flex: 1;">
                  <div style="font-weight: bold; ${
                    isCompleted ? "color: var(--success-color);" : ""
                  }">${challenge.title} ${isCompleted ? "✓" : ""}</div>
                  <div style="font-size: 0.9rem; color: var(--text-secondary);">${
                    challenge.description
                  }</div>
                </div>
              </div>
              <div style="margin-bottom: 0.5rem;">
                <div style="background: #e5e7eb; border-radius: 10px; overflow: hidden; height: 8px;">
                  <div style="background: ${
                    isCompleted
                      ? "var(--success-color)"
                      : "var(--primary-color)"
                  }; height: 100%; width: ${progressPercent}%; transition: width 0.3s ease;"></div>
                </div>
                <div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.2rem;">
                  Progress: ${challenge.progress}/${challenge.target}
                </div>
              </div>
              <div style="font-size: 0.8rem; color: var(--warning-color);">
                Reward: ${challenge.reward}
              </div>
            </div>
          `;
        });

        challengesContent.innerHTML = content;
        document.getElementById("dailyChallengesModal").classList.add("show");
      }

      function closeDailyChallenges() {
        document
          .getElementById("dailyChallengesModal")
          .classList.remove("show");
      }

      // Power-Ups System
      function showPowerUps() {
        const powerUpsContent = document.getElementById("powerUpsContent");

        const powerUpsList = [
          {
            name: "Smart Hints",
            description: "Get hints about which cards to play",
            count: gameState.powerUps.hints,
            icon: "💡",
            action: "useHintPowerUp",
          },
          {
            name: "Skip Turn",
            description: "Force computer to skip their turn",
            count: gameState.powerUps.skipTurn,
            icon: "⏭️",
            action: "useSkipTurnPowerUp",
          },
          {
            name: "Peek Cards",
            description: "See computer's cards for 5 seconds",
            count: gameState.powerUps.peekCards,
            icon: "👁️",
            action: "usePeekCardsPowerUp",
          },
          {
            name: "Extra Time",
            description: "Add 30 seconds to thinking time",
            count: gameState.powerUps.extraTime,
            icon: "⏰",
            action: "useExtraTimePowerUp",
          },
        ];

        let content = `
          <div style="margin-bottom: 1rem;">
            <h3>Available Power-Ups</h3>
            <p style="color: var(--text-secondary); font-size: 0.9rem;">Use power-ups strategically to gain advantages!</p>
          </div>
        `;

        powerUpsList.forEach((powerUp) => {
          content += `
            <div style="display: flex; align-items: center; justify-content: space-between; padding: 1rem; margin-bottom: 0.5rem; background: rgba(79, 70, 229, 0.1); border-radius: 10px;">
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <span style="font-size: 1.5rem;">${powerUp.icon}</span>
                <div>
                  <div style="font-weight: bold;">${powerUp.name}</div>
                  <div style="font-size: 0.9rem; color: var(--text-secondary);">${
                    powerUp.description
                  }</div>
                </div>
              </div>
              <div style="text-align: center;">
                <div style="background: var(--primary-color); color: white; padding: 0.3rem 0.6rem; border-radius: 15px; font-size: 0.8rem; margin-bottom: 0.3rem;">
                  ${powerUp.count}
                </div>
                <button class="message-btn" 
                        onclick="${powerUp.action}()" 
                        ${
                          powerUp.count === 0 ||
                          !gameState.playerTurn ||
                          gameState.gameOver
                            ? "disabled"
                            : ""
                        }
                        style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                  Use
                </button>
              </div>
            </div>
          `;
        });

        powerUpsContent.innerHTML = content;
        document.getElementById("powerUpsModal").classList.add("show");
      }

      function closePowerUps() {
        document.getElementById("powerUpsModal").classList.remove("show");
      }

      function savePowerUps() {
        localStorage.setItem(
          "powerUpHints",
          gameState.powerUps.hints.toString()
        );
        localStorage.setItem(
          "powerUpSkipTurn",
          gameState.powerUps.skipTurn.toString()
        );
        localStorage.setItem(
          "powerUpPeekCards",
          gameState.powerUps.peekCards.toString()
        );
        localStorage.setItem(
          "powerUpExtraTime",
          gameState.powerUps.extraTime.toString()
        );
      }

      // Power-up functions
      function useHintPowerUp() {
        if (
          gameState.powerUps.hints <= 0 ||
          !gameState.playerTurn ||
          gameState.gameOver
        )
          return;

        gameState.powerUps.hints--;
        savePowerUps();
        closePowerUps();

        // Highlight best playable cards
        const playableCards = gameState.playerHand.filter((card) =>
          isCardPlayable(card)
        );
        if (playableCards.length > 0) {
          // Find the best card to suggest
          const bestCard =
            playableCards.find((card) => card.type === "action") ||
            playableCards.find((card) => card.type === "wild") ||
            playableCards[0];

          const cardIndex = gameState.playerHand.indexOf(bestCard);
          const cardElement = document.querySelector(
            `#playerHand .card:nth-child(${cardIndex + 1})`
          );

          if (cardElement) {
            cardElement.style.border = "3px solid gold";
            cardElement.style.boxShadow = "0 0 15px gold";

            setTimeout(() => {
              cardElement.style.border = "";
              cardElement.style.boxShadow = "";
            }, 5000);
          }

          showMessage(
            "💡 Power-Up Used!",
            `The highlighted card is your best play: ${bestCard.color} ${bestCard.value}`
          );
        }

        playSound("achievement");
      }

      function useSkipTurnPowerUp() {
        if (
          gameState.powerUps.skipTurn <= 0 ||
          gameState.playerTurn ||
          gameState.gameOver
        )
          return;

        gameState.powerUps.skipTurn--;
        savePowerUps();
        closePowerUps();

        // Skip computer's next turn
        gameState.playerTurn = true;
        updateDisplay();
        showMessage("⏭️ Power-Up Used!", "Computer's turn has been skipped!");
        playSound("achievement");
      }

      function usePeekCardsPowerUp() {
        if (
          gameState.powerUps.peekCards <= 0 ||
          !gameState.playerTurn ||
          gameState.gameOver
        )
          return;

        gameState.powerUps.peekCards--;
        savePowerUps();
        closePowerUps();

        // Show computer cards temporarily
        const computerHand = document.getElementById("computerHand");
        const originalContent = computerHand.innerHTML;

        // Show actual cards
        computerHand.innerHTML = "";
        gameState.computerHand.forEach((card, index) => {
          const cardElement = createCardElement(card, index, true);
          cardElement.style.transform = "scale(0.8)";
          computerHand.appendChild(cardElement);
        });

        showMessage(
          "👁️ Power-Up Used!",
          "You can see the computer's cards for 5 seconds!"
        );
        playSound("achievement");

        // Restore after 5 seconds
        setTimeout(() => {
          computerHand.innerHTML = originalContent;
        }, 5000);
      }

      function useExtraTimePowerUp() {
        if (gameState.powerUps.extraTime <= 0) return;

        gameState.powerUps.extraTime--;
        savePowerUps();
        closePowerUps();

        // Add 30 seconds to game time (visual effect)
        showMessage(
          "⏰ Power-Up Used!",
          "You have extra thinking time for your moves!"
        );
        playSound("achievement");
      }

      // Initialize game when page loads
      window.addEventListener("load", () => {
        // Load saved settings
        gameState.soundEnabled = localStorage.getItem("unosound") !== "false";
        gameState.animationsEnabled =
          localStorage.getItem("unoanimations") !== "false";
        gameState.showHints = localStorage.getItem("unohints") !== "false";

        // Update sound toggle icon
        const icon = document.querySelector("#soundToggle i");
        icon.className = gameState.soundEnabled
          ? "fas fa-volume-up"
          : "fas fa-volume-mute";

        // Initialize daily challenges
        generateDailyChallenges();

        // Initialize today's word count
        const today = new Date().toDateString();
        const lastPlayDate = localStorage.getItem("lastPlayDate");
        if (lastPlayDate !== today) {
          gameState.wordsLearnedToday = 0;
          localStorage.setItem("lastPlayDate", today);
        } else {
          // Count words learned today from progress
          gameState.wordsLearnedToday = Object.values(
            gameState.wordProgress
          ).filter((progress) => {
            const lastSeen = new Date(progress.lastSeen);
            return lastSeen.toDateString() === today && progress.correct > 0;
          }).length;
        }

        initGame();
      });

      // Keyboard shortcuts
      document.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          if (gameState.playerTurn && !gameState.gameOver) {
            drawCard();
          }
        } else if (e.key === "u" || e.key === "U") {
          if (gameState.playerHand.length === 1) {
            callUno();
          }
        } else if (e.key === "n" || e.key === "N") {
          newGame();
        }
      });

      // Prevent context menu on cards
      document.addEventListener("contextmenu", (e) => {
        if (e.target.classList.contains("card")) {
          e.preventDefault();
        }
      });
    </script>

    <script src="../js/game-ads.js"></script>
  </body>
</html>
